---
title: "SpaDES 4 Dummies - Example 2"
author: "Ceres Barros"
date: "Last updated: `r Sys.Date()`"
output: 
  bookdown::html_document2:
    theme: flatly
    toc: true
    number_sections: FALSE
    toc_float: TRUE
    toc_depth: 4
    highlight: zenburn
    css: "style.css"
editor_options: 
  chunk_output_type: console
bibliography: citations/references.bib
---

```{r setup, include=FALSE}
options("repos" = c(CRAN = "https://cran.rstudio.com"))
knitr::opts_chunk$set(cache = 2, cache.rebuild = FALSE)
```

# A simple, but realistic example of `SpaDES`

In [Example 1](https://htmlpreview.github.io/?https://github.com/CeresBarros/SpaDES4Dummies/blob/master/Example1_DummyModel.html) of this guide, we described how to create new `SpaDES` modules, their different components, how to link different modules and how to set up and run a simulation.

Here, we assume that you are familiar with these steps, but go further in showing important `SpaDES` features that facilitate many of the steps common to most ecological modelling exercises. For the sake of simplicity, we focus our example on projecting a species' distribution as a function of climate covariates. Yet, the true power of `SpaDES` is more evident when using complex dynamic simulation models parametrized using large datasets and ran across large spatial areas.

This example is broken into four main parts: [Module creation and coding], [Running the model], [Caching], and [Best practices]. By no mean does it cover caching or best practices in full, as each of these topics is very extensive, but it highlights some of their essentials in `SpaDES` and from our own experience.

## The example: projecting species distribution shifts under climate change

Species distribution models (SDMs) have been widely used in ecology to predict how species presences and absences across a landscape may change under changing environmental conditions. As a result, there are several R packages that have been built with this in mind [e.g. `dismo` @dismo; `biomod2` @biomod2] and many ecologists do these analyses exclusively in R.

Often, these analyses are run only once for a given set of species, baseline and projected environmental conditions, and researchers will have a few R scripts (or maybe just one longer script) that load the data into R, do any necessary pre-processing steps, fit the models and run species distribution projections. The usefulness of `SpaDES` comes when we want an automated and standardized workflow that can be easily updated with new data and adapted with new algorithms. `SpaDES` provides a common standard and a modular approach to modelling that facilitates expanding, debugging and sharing code, but also various tools that bring many well-known best practices from computer- and data-science workflows, including reproducible, modular workflows, and caching, to the realm of ecological modelling, so that they can be used by non-computer-scientists with minimal learning. In an SDM project this means that updating data and algorithms, and automating iterative forecasting become easier and less prone to errors. When `SpaDES` modules are open and shared, this also expands a potential pool of users who can themselves help improve the code.

## **Module creation and coding**

With the above in mind, in this example we created three modules that source and pre-process data ('data modules') and a module that fits an SDM and iteratively forecasts species distributions (we call it a 'simulation module', although the simulation only involves predicting from a statistical model). The idea is that we could, for instance, provide different data sources to one of the data modules and only update the parts of the simulation that are affected by this change (i.e. presumably the other data module steps with not be affected). Or, we could develop a second simulation module using a different SDM approach and swap the two modules to inspect which provides better predictions.

Our data modules are *speciesAbundanceData* and *climateData*. The simulation module is *projectSpeciesDist*. We start by creating a "global" `.R` script to set up and control the simulation. In this example this script is called `Example2_SDMMaxent.R`. The script begins with a few lines of code that ensure necessary packages are installed and loaded (see [Reproducible package installation]), defines the necessary folder directories for the simulation and creates the modules in the `modules/` folder:

```{r globalscript, eval = FALSE}
## Get necessary R packages, but don't load any
if (!require("Require")) install.packages("Require")
Require::Require("PredictiveEcology/SpaDES.install@development")
SpaDES.install::installSpaDES(ask = TRUE)

## decide where you're wtorking
mainDir <- "."

# mainDir <- getwd()
SpaDES.core::setPaths(cachePath = file.path(mainDir, "cache"),
                      inputPath = file.path(mainDir, "inputs"),
                      modulePath = file.path(mainDir, "modules"),
                      outputPath = file.path(mainDir, "outputs"))

simPaths <- SpaDES.core::getPaths() ## check that this is what you wanted

## Let's create a self-contained module that will simulate the species' abundance for any given period of time and frequency.
if (!dir.exists(file.path(simPaths$modulePath, "speciesAbundanceData"))){
  SpaDES.core::newModule(name = "speciesAbundanceData", path = simPaths$modulePath)
}

if (!dir.exists(file.path(simPaths$modulePath, "climateData"))){
  SpaDES.core::newModule(name = "climateData", path = simPaths$modulePath)
}

if (!dir.exists(file.path(simPaths$modulePath, "projectSpeciesDist"))){
  SpaDES.core::newModule(name = "projectSpeciesDist", path = simPaths$modulePath)
}
```

```{r globalscriptHidden, include = FALSE}
## decide where you're wtorking
mainDir <- "."

# mainDir <- getwd()
SpaDES.core::setPaths(cachePath = file.path(mainDir, "cache"),
                      inputPath = file.path(mainDir, "inputs"),
                      modulePath = file.path(mainDir, "modules"),
                      outputPath = file.path(mainDir, "outputs"))

simPaths <- SpaDES.core::getPaths() ## check that this is what you wanted

## Let's create a self-contained module that will simulate the species' abundance for any given period of time and frequency.
if (!dir.exists(file.path(simPaths$modulePath, "speciesAbundanceData"))){
  SpaDES.core::newModule(name = "speciesAbundanceData", path = simPaths$modulePath)
}

if (!dir.exists(file.path(simPaths$modulePath, "climateData"))){
  SpaDES.core::newModule(name = "climateData", path = simPaths$modulePath)
}

if (!dir.exists(file.path(simPaths$modulePath, "projectSpeciesDist"))){
  SpaDES.core::newModule(name = "projectSpeciesDist", path = simPaths$modulePath)
}
```

Notice how we protect the `newModule` call with an `if` statement that first detects whether the module directory exists already. This is necessary to prevent overwriting existing modules should this script be run a second time in the same location (see [Protect yourself and others from common mistakes/problems]).

`setPaths` will create the project folder directories in case they to not exist, but will not overwrite existing ones with empty new folders.

Finally, we do not load any R packages yet, as we will later use `Require` to make sure all module dependencies are installed prior to running the simulation (see [Reproducible package installation]). Because `Require` may attempt to install missing packages and because installing packages should be done in a clean R session, we will only load any packages after all the installation steps are complete.

### Data modules

The next two sections show our two data modules `.R` scripts and highlight particularly important aspects of each script. We assume you are already familiar with the different parts of a module `.R` script; if not, see [Example 1](https://htmlpreview.github.io/?https://github.com/CeresBarros/SpaDES4Dummies/blob/master/Example1_DummyModel.html). We do not discuss the module `.Rmd` files, which should document each module in detail (see [Module documentation (module .Rmd)]).

#### *speciesAbundanceData* module:

This module downloads freely available spatial layers of *Picea glauca* percent cover (% cover) across Canada and pre-processes them to match a user-supplied study area raster (note that we use the new `terra` package throughout this example, since the `raster` package will soon be discontinued). The main outputs of this module are the processed spatial raster layer of *Picea glauca* % cover (`sppAbundanceRas`), and its equivalent in the form of a `data.table`. The `data.table` contains added information about the year of the simulation during which the data should be used (here only the first year, as it is used to fit the SDM). We opted to export the information in two formats for demonstrational purposes, but also because we could envision that this model (i.e. group of modules) could save the species distribution projections for several points in time in the more compact format of a `data.table` -- large raster layers can consume a considerable amount of disk space.

```{r dataModule1, eval = FALSE}
## Everything in this file and any files in the R directory are sourced during `simInit()`;
## all functions and objects are put into the `simList`.
## To use objects, use `sim$xxx` (they are globally available to all modules).
## Functions can be used inside any function that was sourced in this module;
## they are namespaced to the module, just like functions in R packages.
## If exact location is required, functions will be: `sim$.mods$<moduleName>$FunctionName`.
defineModule(sim, list(
  name = "speciesAbundanceData",
  description = paste("Data module to prepare tree species cover data for species distribution modelling.", 
                      "Defaults to using Canadian National Forest Inventory data."),
  keywords = c("minimal SpaDES example", "species distribution model"),
  authors = person("Me", email = "me@example.com", role = c("aut", "cre")),
  childModules = character(0),
  version = list(speciesAbundanceData = "0.0.0.9000"),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = list("README.md", "speciesAbundanceData.Rmd"), ## same file
  reqdPkgs = list("PredictiveEcology/SpaDES.core@development (>=1.0.10.9000)",
                  "terra", "ggplot2", "rasterVis"),
  parameters = bindrows(
    #defineParameter("paramName", "paramClass", value, min, max, "parameter description"),
    defineParameter("sppAbundURL", "character", 
                    paste0("https://ftp.maps.canada.ca/pub/nrcan_rncan/Forests_Foret/",
                           "canada-forests-attributes_attributs-forests-canada/",
                           "2001-attributes_attributs-2001/NFI_MODIS250m_2001_kNN_Species_Pice_Gla_v1.tif"), NA, NA,
                    paste("URL where the first RasterLayer of species abundance resides.",
                          "This will be the abundance data used to fit the species ditribution model.",
                          "Defaults to *Picea glauca* percent cover across Canada, in 2001", 
                          "(from Canadian National Forest Inventory forest attributes)")),
    defineParameter(".plots", "character", "screen", NA, NA,
                    "Used by Plots function, which can be optionally used here"),
    defineParameter(".plotInitialTime", "numeric", start(sim), NA, NA,
                    "Describes the simulation time at which the first plot event should occur."),
    defineParameter(".plotInterval", "numeric", NA, NA, NA,
                    "Describes the simulation time interval between plot events."),
    defineParameter(".saveInitialTime", "numeric", NA, NA, NA,
                    "Describes the simulation time at which the first save event should occur."),
    defineParameter(".saveInterval", "numeric", NA, NA, NA,
                    "This describes the simulation time interval between save events."),
    defineParameter(".studyAreaName", "character", NA, NA, NA,
                    "Human-readable name for the study area used. If NA, a hash of studyArea will be used."),
    ## .seed is optional: `list('init' = 123)` will `set.seed(123)` for the `init` event only.
    defineParameter(".seed", "list", list(), NA, NA,
                    "Named list of seeds to use for each event (names)."),
    defineParameter(".useCache", "logical", FALSE, NA, NA,
                    "Should caching of events or module be used?")
  ),
  inputObjects = bindrows(
    #expectsInput("objectName", "objectClass", "input object description", sourceURL, ...),
    expectsInput("studyAreaRas", objectClass = "RasterLayer", 
                 desc = "A binary raster of the study area")
  ),
  outputObjects = bindrows(
    #createsOutput("objectName", "objectClass", "output object description", ...),
    createsOutput("sppAbundanceDT", "data.table", 
                  desc = paste("Species abundance data from `sppAbundanceRas`, with columns 'cell',",
                               "'x', 'y', 'sppAbund' and 'year' (an integer matching the number in",
                               "names(`sppAbundanceRas`)." )),
    createsOutput("sppAbundanceRas", "SpatRaster", 
                  desc = paste("A species abundance layer used to fit a species distribution model",
                               "at the start of the simulation. Layers named as:",
                               "paste('year', start(sim):end(sim), sep = '_')). Data obtained from",
                               "P(sim)$sppAbundURL"))
  )
))

## event types
#   - type `init` is required for initialization

doEvent.speciesAbundanceData = function(sim, eventTime, eventType, debug = FALSE) {
  switch(
    eventType,
    init = {
      ## do stuff for this event
      sim <- abundanceInit(sim)
      
      ## schedule future event(s)
      sim <- scheduleEvent(sim, eventTime = P(sim)$.plotInitialTime, 
                           moduleName = "speciesAbundanceData", eventType = "abundPlot",
                           eventPriority = .normal())
    },
    abundPlot = {
      ## do stuff for this event
      sim <- abundancePlot(sim)
    },
    warning(paste("Undefined event type: '", current(sim)[1, "eventType", with = FALSE],
                  "' in module '", current(sim)[1, "moduleName", with = FALSE], "'", sep = ""))
  )
  return(invisible(sim))
}

## event functions
#   - keep event functions short and clean, modularize by calling subroutines from section below.

## Initialisation Event function
abundanceInit <- function(sim) {
  ## download data - prepInputs does all the heavy-lifting of dowloading and pre-processing the layer and caches.
  sppAbundanceRas <- prepInputs(targetFile = "NFI_MODIS250m_2001_kNN_Species_Pice_Gla_v1.tif",
                                url = P(sim)$sppAbundURL,
                                fun = "terra::rast",
                                overwrite = TRUE,
                                cacheRepo = cachePath(sim))
  sppAbundanceRas <- project(sppAbundanceRas, sim$studyAreaRas)
  sppAbundanceRas <- crop(sppAbundanceRas, sim$studyAreaRas)
  sppAbundanceRas <- mask(sppAbundanceRas, sim$studyAreaRas)
  
  names(sppAbundanceRas) <- paste("year", time(sim), sep = "_")
  
  sppAbundanceDT <- as.data.table(as.data.frame(sppAbundanceRas, xy = TRUE, cells = TRUE))
  sppAbundanceDT[, year := as.integer(sub("year_", "", names(sppAbundanceRas)))]
  setnames(sppAbundanceDT, "year_1", "sppAbund")
  
  ## export to sim
  sim$sppAbundanceRas <- sppAbundanceRas
  sim$sppAbundanceDT <- sppAbundanceDT
  
  return(invisible(sim))
}

## Plotting event function 
abundancePlot <- function(sim) {
  ## plot species abundance
  Plots(sim$sppAbundanceRas, fn = plotSpatRaster, types = P(sim)$.plots,
        usePlot = TRUE, filename = file.path(outputPath(sim), "figures", "speciesAbundance"), 
        plotTitle = "Species abundance data", xlab = "Longitude", y = "Latitude")
  
  return(invisible(sim))
}


.inputObjects <- function(sim) {
  
  #cacheTags <- c(currentModule(sim), "function:.inputObjects") ## uncomment this if Cache is being used
  dPath <- asPath(getOption("reproducible.destinationPath", dataPath(sim)), 1)
  message(currentModule(sim), ": using dataPath '", dPath, "'.")
  
  # ! ----- EDIT BELOW ----- ! #
  
  if (!suppliedElsewhere(sim$studyAreaRas)) {
    ## code check: did the user supply a study area?
    stop("Please supply a 'studyAreaRas' SpatRaster")
  }
  
  # ! ----- STOP EDITING ----- ! #
  return(invisible(sim))
}
```

#### *climateData* module:

This module downloads and processes freely available spatial layers of four bioclimatic variables used to fit the SDM of *Picea glauca* in the study area supplied by the user. The module uses an different way to download data. It relies on two input `data.tables` that contain the URLs for each climate covariate, one for baseline conditions, the other for projected climate conditions, both containing information about when each layer should be used during the simulation (the "year "column).

We have only supplied one set of default baseline climate conditions (`baselineClimateURLs`) and climate projections (`projClimateURLs`) data sources, both of which are pre-processed to match the study area raster layer and then compiled in the `climateDT` object. These layers are downloaded from WorldClim at 2.5 minutes resolution. The baseline climate data correspond to the 1970-2000 period, which aligns well with the species % cover data year (2001). The climate projections are for the 2081-2100 period, and and come from the CanESM5 climate model under the SSP 585 climate scenario. We encourage providing different (or additional) URLs referring to projections for other climate periods, other climate models and other climate scenarios (see [WorldClim](https://www.worldclim.org/data/cmip6/cmip6climate.html) for a list of climate projections).

When providing URLs to obtain data for several projection periods, pay special attention to the "year" column of `projClimateURLs` -- the URLs need to correspond to the simulation year during which they will be used (not necessarily the actual climate year, unless the simulation years follow the same numbering).

```{r dataModule2, eval = FALSE}
## Everything in this file and any files in the R directory are sourced during `simInit()`;
## all functions and objects are put into the `simList`.
## To use objects, use `sim$xxx` (they are globally available to all modules).
## Functions can be used inside any function that was sourced in this module;
## they are namespaced to the module, just like functions in R packages.
## If exact location is required, functions will be: `sim$.mods$<moduleName>$FunctionName`.
defineModule(sim, list(
  name = "climateData",
  description = paste("Data module to prepare climate data for species distribution modelling.", 
                      "Defaults to using bioclimatic variables from Worldclim."),
  keywords = c("minimal SpaDES example", "species distribution model"),
  authors = person("Me", email = "me@example.com", role = c("aut", "cre")),
  childModules = character(0),
  version = list(climateData = "0.0.0.9000"),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = list("README.md", "climateData.Rmd"), ## same file
  reqdPkgs = list("PredictiveEcology/SpaDES.core@development (>=1.0.10.9000)",
                  "ggplot2", "rasterVis", "terra", "data.table"),
  parameters = bindrows(
    #defineParameter("paramName", "paramClass", value, min, max, "parameter description"),
    defineParameter(".plots", "character", "screen", NA, NA,
                    "Used by Plots function, which can be optionally used here"),
    defineParameter(".plotInitialTime", "numeric", start(sim), NA, NA,
                    "Describes the simulation time at which the first plot event should occur."),
    defineParameter(".plotInterval", "numeric", NA, NA, NA,
                    "Describes the simulation time interval between plot events."),
    defineParameter(".saveInitialTime", "numeric", NA, NA, NA,
                    "Describes the simulation time at which the first save event should occur."),
    defineParameter(".saveInterval", "numeric", NA, NA, NA,
                    "This describes the simulation time interval between save events."),
    defineParameter(".studyAreaName", "character", NA, NA, NA,
                    "Human-readable name for the study area used. If NA, a hash of studyArea will be used."),
    ## .seed is optional: `list('init' = 123)` will `set.seed(123)` for the `init` event only.
    defineParameter(".seed", "list", list(), NA, NA,
                    "Named list of seeds to use for each event (names)."),
    defineParameter(".useCache", "logical", FALSE, NA, NA,
                    "Should caching of events or module be used?")
  ),
  inputObjects = bindrows(
    #expectsInput("objectName", "objectClass", "input object description", sourceURL, ...),
    expectsInput("baselineClimateURLs", "data.table", 
                 desc = paste("A table with columns 'vars', 'URL', 'targetFile' and 'year', containing",
                              "variable names, URLs and raster file names of each climate covariate",
                              "used in the species distribution models. Year is the first year of the", 
                              "simulation (not the reference climate period). Defaults to Worldclim's",
                              "'bio1', 'bio4', 'bio12' and 'bio15' bioclimatic variables for the 1970-2000",
                              "climate period, at 2.5 minutes.")),
    expectsInput("projClimateURLs", "data.table", 
                 desc = paste("Same as `baselineClimateURLs` but refering to projected climate layers.",
                              "Variable names in 'vars' need to the same as in `baselineClimateURLs`",
                              "and P(sim)$projClimateURLs. Years should correspond to simulation years.",
                              "Defaults to 2081-2100 projections using the CanESM5 climate model and the",
                              "SSP 585 climate scenario, at 2.5 minutes, obtained from Worldclim.")),
    expectsInput("studyAreaRas", objectClass = "SpatRaster", 
                 desc = "A binary raster of the study area")
  ),
  outputObjects = bindrows(
    #createsOutput("objectName", "objectClass", "output object description", ...),
    createsOutput("climateDT", "data.table", 
                  desc = paste("A data.table with as many columns as the climate covariates", 
                               "used in the species distribution model and 'year' column describing",
                               "the simulation year to which the data corresponds.")),
    createsOutput("baselineClimateRas", "SpatRaster", 
                  desc = paste("Baseline climate layers obtained from `baselineClimateURLs`")),
    createsOutput("projClimateRas", "SpatRaster", 
                  desc = paste("Baseline climate layers obtained from `projClimateURLs`"))
  )
))

## event types
#   - type `init` is required for initialization

doEvent.climateData = function(sim, eventTime, eventType, debug = FALSE) {
  switch(
    eventType,
    init = {
      ## do stuff for this event
      sim <- climateInit(sim)
      
      ## schedule future event(s)
      sim <- scheduleEvent(sim, eventTime = P(sim)$.plotInitialTime, 
                           moduleName = "climateData", eventType = "climPlot",
                           eventPriority = .normal())
    },
    climPlot = {
      ## do stuff for this event
      sim <- climatePlot(sim)
    },
    warning(paste("Undefined event type: '", current(sim)[1, "eventType", with = FALSE],
                  "' in module '", current(sim)[1, "moduleName", with = FALSE], "'", sep = ""))
  )
  return(invisible(sim))
}

## event functions
#   - keep event functions short and clean, modularize by calling subroutines from section below.

## Initialisation Event function
climateInit <- function(sim) {
  ## GET BASELINE DATA
  ## make a vector of archive (zip) file names if the url points to one.
  archiveFiles <- sapply(sim$baselineClimateURLs$URL, function(URL) {
    if (grepl("\\.zip$", basename(URL))) {
      basename(URL)
    } else {
      NULL
    }
  }, USE.NAMES = FALSE)
  
  ## download data - prepInputs does all the heavy-lifting of dowloading and pre-processing the layer and caches.
  baselineClimateRas <- Cache(Map, 
                              f = prepInputs,
                              url = sim$baselineClimateURLs$URL,
                              targetFile = sim$baselineClimateURLs$targetFile,
                              archive = archiveFiles,
                              MoreArgs = list(
                                fun = "terra::rast",
                                overwrite = TRUE,
                                rasterToMatch = sim$studyAreaRas,
                                cacheRepo = cachePath(sim)),
                              cacheRepo = cachePath(sim))
  
  names(baselineClimateRas) <- sim$baselineClimateURLs$vars
  ## make a stack
  baselineClimateRas <- rast(baselineClimateRas)
  
  ## make a data.table 
  baselineClimateData <- as.data.table(as.data.frame(baselineClimateRas, xy = TRUE, cells = TRUE))
  baselineClimateData[, year := 1L]
  
  ## GET PROJECTED DATA
  ## make a vector of archive (zip) file names if the url points to one.
  archiveFiles <- lapply(sim$projClimateURLs$URL, function(URL) {
    if (grepl("\\.zip$", basename(URL))) {
      basename(URL)
    } else {
      NULL
    }
  })
  
  ## download data - prepInputs does all the heavy-lifting of dowloading and pre-processing the layer and caches.
  projClimateRas <- Cache(Map, 
                          f = prepInputs,
                          url = sim$projClimateURLs$URL,
                          targetFile = sim$projClimateURLs$targetFile,
                          archive = archiveFiles,
                          MoreArgs = list(
                            fun = "terra::rast",
                            overwrite = TRUE,
                            rasterToMatch = sim$studyAreaRas,
                            cacheRepo = cachePath(sim)),
                          cacheRepo = cachePath(sim))
  
  ## these rasters are different. The tif file contains all the variables in different layers
  ## so, for each variable, we need to keep only the layer of interest
  projClimateRas <- mapply(function(stk, var) {
    lyr <- which(sub(".*_", "BIO", names(projClimateRas[[1]])) == var)
    return(stk[[lyr]])
  }, stk = projClimateRas, var = sim$projClimateURLs$vars)
  names(projClimateRas) <- sim$projClimateURLs$vars
  
  ## make a stack
  projClimateRas <- rast(projClimateRas)
  
  ## make a data.table 
  projClimateData <- as.data.table(as.data.frame(projClimateRas, xy = TRUE, cells = TRUE))
  projClimateData[, year := 2L]
  
  ## bind the two data.tables
  if (!identical(sort(names(baselineClimateData)), sort(names(projClimateData)))) {
    stop("Variable names in `projClimateURLs` differ from those in `baselineClimateURLs`")
  }
  
  ## check
  if (!compareGeom(baselineClimateRas, projClimateRas, res = TRUE, stopOnError = FALSE)) {
    stop("`baselineClimateRas` and `projClimateRas` do not have the same raster properties")
  }
  
  ## export to sim
  sim$baselineClimateRas <- baselineClimateRas
  sim$projClimateRas <- projClimateRas
  sim$climateDT <- rbindlist(list(baselineClimateData, projClimateData), use.names = TRUE)
  
  return(invisible(sim))
}

## Plotting event function 
climatePlot <- function(sim) {
  ## plot species abundance
  allRasters <- rast(list(sim$baselineClimateRas, sim$projClimateRas))
  names(allRasters) <- c(paste(names(sim$baselineClimateRas), "- year 1"),
                         paste(names(sim$projClimateRas), "- year 2"))
  allRasters <- allRasters[[order(names(allRasters))]]
  
  ## Because we are working with SpatRasters, we need to make our own custom 
  ## function (Plots only works with outputs from ggplot or with quickPlot::Plot)
  Plots(allRasters, fn = plotSpatRasterStk, types = P(sim)$.plots,
        usePlot = FALSE,
        filename = file.path(outputPath(sim), "figures", "climateCovariates"))
  
  return(invisible(sim))
}


.inputObjects <- function(sim) {
  #cacheTags <- c(currentModule(sim), "function:.inputObjects") ## uncomment this if Cache is being used
  dPath <- asPath(getOption("reproducible.destinationPath", dataPath(sim)), 1)
  message(currentModule(sim), ": using dataPath '", dPath, "'.")
  
  # ! ----- EDIT BELOW ----- ! #
  
  if (!suppliedElsewhere(sim$studyAreaRas)) {
    ## code check: did the user supply a study area?
    stop("Please supply a 'studyAreaRas' SpatRaster")
  }
  
  if (!is(sim$studyAreaRas, "SpatRaster")) {
    sim$studyAreaRas <- rast(sim$studyAreaRas)
  }
  
  if (!suppliedElsewhere(sim$baselineClimateURLs)) {
    sim$baselineClimateURLs <- data.table(vars = c("BIO1", "BIO4", "BIO12", "BIO15"),
                                          URL = c("https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_2.5m_bio.zip",
                                                  "https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_2.5m_bio.zip",
                                                  "https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_2.5m_bio.zip",
                                                  "https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_2.5m_bio.zip"),
                                          targetFile = c("wc2.1_2.5m_bio_1.tif", "wc2.1_2.5m_bio_4.tif", "wc2.1_2.5m_bio_12.tif", "wc2.1_2.5m_bio_15.tif"),
                                          year = rep(1L, 4))
  }
  
  if (!suppliedElsewhere(sim$projClimateURLs)) {
    sim$projClimateURLs <- data.table(vars = c("BIO1", "BIO4", "BIO12", "BIO15"),
                                      URL = c("https://geodata.ucdavis.edu/cmip6/2.5m/CanESM5/ssp585/wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif",
                                              "https://geodata.ucdavis.edu/cmip6/2.5m/CanESM5/ssp585/wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif",
                                              "https://geodata.ucdavis.edu/cmip6/2.5m/CanESM5/ssp585/wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif",
                                              "https://geodata.ucdavis.edu/cmip6/2.5m/CanESM5/ssp585/wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif"),
                                      targetFile = c("wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif", 
                                                     "wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif", 
                                                     "wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif", 
                                                     "wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif"),
                                      year = rep(2L, 4))
  } 
  
  # ! ----- STOP EDITING ----- ! #
  return(invisible(sim))
}
```

We draw your attention to a few particular aspects of the data modules:

-   How we took care to define the data classes of the parameters, expected inputs and module outputs in their respective metadata sections;

-   How we added additional R packages necessary to run the module;

-   How we added default values for parameters and inputs explicitly used by the modules (others like `.plotInterval` were left as `NA`). The exception to this is the `studyAreaRas` input object for which we do not provide a default. However, we added a code check in `.inputObject` that stops interrupts R if this object is not in `sim`.

-   How we use the function `prepInputs` to do most of the heavy-lifting of downloading data and spatial pre-processing. This function is able to recognize whether the data has already been downloaded, and can cache all spatial processing tasks (see [Caching]). In some cases (e.g. Code block \@ref(code:dataModule2)) we wrap `prepInputs` in a `Map` call to loop through several URLs and download and pre-process many data layers. This `Map` call can itself be cached with `Cache`.

-   How we use the function `Plots` to control plotting to the screen device and/or save to image files depending on the `P(sim)$.plots` argument. Note that `Plots` works best with plotting functions that output `ggplot` objects, or that are compatible with `quickPlot::Plot`.

-   The fact that neither module depends on the other. This is not a required feature of data modules, but just so happens to be the case in this example. In fact, in more complex modelling frameworks we often have several data modules that depend on each other (e.g., [LandR *Biomass_speciesData*](https://github.com/PredictiveEcology/Biomass_speciesData) sources and processes tree species percent cover data that is used by [LandR *Biomass_borealDataPrep*](https://github.com/PredictiveEcology/Biomass_borealDataPrep) to estimate several parameters for the forest landscape simulation model [LandR *Biomass_core*](https://github.com/PredictiveEcology/Biomass_core)).

-   How we export objects created within the module functions to `sim`. Without doing so, these objects are lost after the function is executed.

#### Simulation module

The Code block \@ref(code:simulationModule) shows the `.R` script for the *projectSpeciesDist* module. This module depends entirely on the other two, as we did not provide any default input objects in the `.inputObjects` function. This is, of course, not good practice, but again we warn the user early on (in the `.inputObjects` function) if the module cannot find the necessary inputs.

This module fits an SDM using MaxEnt via the `dismo` package. We highly recommend having a look at [this guide](https://rspatial.org/raster/sdm/index.html) to learn about fitting SDMs with `dismo` and more.

The module converts any non-binary species data into presences and absences to model species occurrence probabilities.

```{r simulationModule, eval = FALSE}
## Everything in this file and any files in the R directory are sourced during `simInit()`;
## all functions and objects are put into the `simList`.
## To use objects, use `sim$xxx` (they are globally available to all modules).
## Functions can be used inside any function that was sourced in this module;
## they are namespaced to the module, just like functions in R packages.
## If exact location is required, functions will be: `sim$.mods$<moduleName>$FunctionName`.
defineModule(sim, list(
  name = "projectSpeciesDist",
  description = "",
  keywords = "",
  authors = structure(list(list(given = c("First", "Middle"), family = "Last", role = c("aut", "cre"), email = "email@example.com", comment = NULL)), class = "person"),
  childModules = character(0),
  version = list(projectSpeciesDist = "0.0.0.9000"),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = list("README.md", "projectSpeciesDist.Rmd"), ## same file
  reqdPkgs = list("SpaDES.core (>=1.0.10.9006)", "ggplot2",
                  "data.table", "dismo"),
  parameters = bindrows(
    #defineParameter("paramName", "paramClass", value, min, max, "parameter description"),
    defineParameter("predVars", "character", c("BIO1", "BIO4", "BIO12", "BIO15"), NA, NA,
                    "Predictors used in Maxent model (see dismo::maxent)."),
    defineParameter(".plots", "character", "screen", NA, NA,
                    "Used by Plots function, which can be optionally used here"),
    defineParameter(".plotInitialTime", "numeric", start(sim), NA, NA,
                    "Describes the simulation time at which the first plot event should occur."),
    ## .seed is optional: `list('init' = 123)` will `set.seed(123)` for the `init` event only.
    defineParameter(".seed", "list", list(), NA, NA,
                    "Named list of seeds to use for each event (names)."),
    defineParameter(".useCache", "logical", FALSE, NA, NA,
                    "Should caching of events or module be used?")
  ),
  inputObjects = bindrows(
    #expectsInput("objectName", "objectClass", "input object description", sourceURL, ...),
    expectsInput("climateDT", "data.table", 
                 desc = paste("A data.table with as many columns as the climate covariates", 
                              "used in the species distribution model and 'year' column describing",
                              "the simulation year to which the data corresponds.")),
    expectsInput("sppAbundanceDT", "data.table", 
                 desc = paste("A species abundance data. Converted to presence/absence data, if not binary")),
  ),
  outputObjects = bindrows(
    #createsOutput("objectName", "objectClass", "output object description", ...),
    createsOutput(objectName = "sppDistProj", objectClass = "SpatRaster",
                  desc = paste("Species distribution projections - raw predictions.",
                               "Each layer corresponds to a prediciton year")),
    createsOutput(objectName = "evalOut", objectClass = "ModelEvaluation", 
                  desc = paste("`sdmOut` model evaluation statistics. Model evaluated on the 20% of",
                               "the data. See `?dismo::evaluation`.")),
    createsOutput(objectName = "sdmData", objectClass = "data.table", 
                  desc = "Input data used to fit `sdmOut`."),
    createsOutput(objectName = "sdmOut", objectClass = "MaxEnt",
                  desc = paste("Fitted species distribution model, using MaxEnt. Model fitted on 80%",
                               "of `sdmData`, with remaining 0% used for evaluation. See `?dismo::maxent`."))
  )
))

## event types
#   - type `init` is required for initialization

doEvent.projectSpeciesDist = function(sim, eventTime, eventType) {
  switch(
    eventType,
    init = {
      ### check for more detailed object dependencies:
      ### (use `checkObject` or similar)
      
      # do stuff for this event
      sim <- SDMInit(sim)
      
      # schedule future event(s)
      sim <- scheduleEvent(sim, start(sim), "projectSpeciesDist", "fitSDM")
      sim <- scheduleEvent(sim, start(sim), "projectSpeciesDist", "projSDM")
      sim <- scheduleEvent(sim, P(sim)$.plotInitialTime, "projectSpeciesDist", "plotProjSDM")
      
    },
    fitSDM = {
      # ! ----- EDIT BELOW ----- ! #
      sim <- fitSDMEvent(sim)
      # ! ----- STOP EDITING ----- ! #
    },
    projSDM = {
      # ! ----- EDIT BELOW ----- ! #
      sim <- projSDMEvent(sim)
      
      sim <- scheduleEvent(sim, time(sim) + 1L, "projectSpeciesDist", "projSDM")
      # ! ----- STOP EDITING ----- ! #
    },
    plotProjSDM = {
      # ! ----- EDIT BELOW ----- ! #
      plotProjEvent(sim)
      
      sim <- scheduleEvent(sim, time(sim) + 1L, "projectSpeciesDist", "plotProjSDM")
      
      # ! ----- STOP EDITING ----- ! #
    },
    warning(paste("Undefined event type: \'", current(sim)[1, "eventType", with = FALSE],
                  "\' in module \'", current(sim)[1, "moduleName", with = FALSE], "\'", sep = ""))
  )
  return(invisible(sim))
}

## event functions
#   - keep event functions short and clean, modularize by calling subroutines from section below.

### template initialization
SDMInit <- function(sim) {
  # # ! ----- EDIT BELOW ----- ! #
  ## at this point we can only have the following columns
  if (!identical(sort(names(sim$sppAbundanceDT)), sort(c("cell", "x", "y", "sppAbund", "year")))) {
    stop(paste("sim$sppAbundanceDT can only have the following columns at the start of year 1:\n",
               paste(c("cell", "x", "y", "sppAbund", "year"), collapse = ", ")))
  }
  
  if (length(setdiff(sim$climateDT$cell, sim$sppAbundanceDT$cell)) > 0 ||
      length(setdiff(sim$sppAbundanceDT$cell, sim$climateDT$cell)) > 0) {
    stop("'cell' columns in `climateDT` and `sppAbundanceDT` have different values")
  }
  
  ## a few data cleaning steps to make sure we have presences and absences:
  sppAbundanceDT <- copy(sim$sppAbundanceDT)
  if (min(range(sppAbundanceDT$sppAbund)) < 0) {
    sppAbundanceDT[sppAbund < 0, sppAbund := 0]
  }
  
  if (max(range(sppAbundanceDT$sppAbund)) > 1) {
    message("Species data is > 1. Converting to presence/absence")
    sppAbundanceDT[sppAbund > 0, sppAbund := 1]
  }
  
  ## join the two datasets - note that there are no input species abundances beyond year 1
  sim$sdmData <- merge(sim$climateDT, sppAbundanceDT[, .(cell, sppAbund, year)], 
                       by = c("cell", "year"), all = TRUE)
  setnames(sim$sdmData, "sppAbund", "presAbs")
  
  # ! ----- STOP EDITING ----- ! #
  return(invisible(sim))
}

fitSDMEvent <- function(sim) {
  # ! ----- EDIT BELOW ----- ! #
  ## break data into training and testing subsets
  dataForFitting <- sim$sdmData[year == time(sim)]
  
  if (nrow(dataForFitting) == 0) {
    stop(paste("No data for year", time(sim), "provided to fit the model"))
  }
  
  group <- kfold(dataForFitting, 5)
  trainData <- dataForFitting[group != 1, ]
  testData <-  dataForFitting[group == 1, ]
  
  predVars <- P(sim)$predVars
  sim$sdmOut <- maxent(x = as.data.frame(trainData[, ..predVars]), 
                       p = trainData$presAbs)
  
  ## set threshold of presence/absence
  sim$evalOut <- evaluate(p = testData[presAbs == 1, ..predVars],
                          a = testData[presAbs == 0, ..predVars],
                          model = sim$sdmOut)
  ## save the threshold of presence/absence in an internal object to this module
  mod$thresh <- threshold(sim$evalOut, 'spec_sens')
  
  # ! ----- STOP EDITING ----- ! #
  return(invisible(sim))
}

projSDMEvent <- function(sim) {
  # ! ----- EDIT BELOW ----- ! #
  ## predict across the full data and make a map
  dataForPredicting <- sim$sdmData[year == time(sim)]
  
  if (nrow(dataForPredicting) == 0) {
    stop(paste("No data for year", time(sim), "provided to calculate predictions"))
  }
  
  predVars <- P(sim)$predVars
  preds <- predict(sim$sdmOut, as.data.frame(dataForPredicting[, ..predVars]),
                   progress = '')
  sppDistProj <- replace(sim$studyAreaRas, which(!is.na(sim$studyAreaRas[])), preds)
  names(sppDistProj) <- paste0("year", time(sim))
  
  if (is.null(sim$sppDistProj)) {
    sim$sppDistProj <- sppDistProj
  } else {
    sim$sppDistProj <- rast(list(sim$sppDistProj, sppDistProj))
  }
  
  # ! ----- STOP EDITING ----- ! #
  return(invisible(sim))
}

plotProjEvent <- function(sim) {
  # ! ----- EDIT BELOW ----- ! #
  checkPath(file.path(outputPath(sim), "figures"), create = TRUE)
  
  if (any(!is.na(P(sim)$.plots))) {
    ## response plot
    ## we can't use Plots to plot and save SDM predictions with dismo.
    ## these are only saved to disk
    notScreen <- setdiff(P(sim)$.plots, "screen")
    if (any(notScreen != "png")) {
      warning(paste(currentModule(sim), "only saves to PNG at the moment."))
    } 
    png(file.path(outputPath(sim), "figures", "SDMresponsePlot.png"))
    response(sim$sdmOut)
    dev.off()
    
    ## species projections
    clearPlot()
    rawValsPlot <- sim$sppDistProj[[paste0("year", time(sim))]]
    Plots(rawValsPlot, fn = plotSpatRaster, types = P(sim)$.plots,
          usePlot = TRUE, filename = file.path(outputPath(sim), "figures", paste0("projRawVals_Year", time(sim))), 
          plotTitle = paste("Maxent raw values -", "year", time(sim)),
          xlab = "Longitude", y = "Latitude")
    PAsPlot <- sim$sppDistProj[[paste0("year", time(sim))]] > mod$thresh
    Plots(PAsPlot, fn = plotSpatRaster, types = P(sim)$.plots,
          usePlot = TRUE, filename = file.path(outputPath(sim), "figures", paste0("projPA_Year", time(sim))), 
          plotTitle = paste("Presence/absence -", "year", time(sim)),
          xlab = "Longitude", y = "Latitude")
  }
  
  # ! ----- STOP EDITING ----- ! #
  return(invisible(sim))
}

.inputObjects <- function(sim) {
  #cacheTags <- c(currentModule(sim), "function:.inputObjects") ## uncomment this if Cache is being used
  dPath <- asPath(getOption("reproducible.destinationPath", dataPath(sim)), 1)
  message(currentModule(sim), ": using dataPath '", dPath, "'.")
  
  # ! ----- EDIT BELOW ----- ! #
  ## check that necessary objects are in the simList or WILL BE supplied  by another module
  if (!suppliedElsewhere("climateDT") | !suppliedElsewhere("sppAbundanceDT") ) {
    stop("Please provide `climateDT` and `sppAbundanceDT`")
  }
  
  # ! ----- STOP EDITING ----- ! #
  return(invisible(sim))
}
```

We draw your attention to:

-   The fact that we could have chosen to save species projections outputs in `sppAbundanceDT` with different year values. In this case we would have also changed this object's name, since MaxEnt is not modelling species abundance, but probability of occurrence.

-   How links with the data modules are established by declaring data modules' output objects as expected inputs for this module.

-   How the `fitSDM` event does not schedule itself (the SDM only needs to be fitted once).

-   How, unlike `fitSDM`, the `projSDM` event schedules itself so that model projections are executed for each year of the simulation, provided that there is corresponding environmental data - notice how the functions `fitSDMEvent` and `projSDMEvent` both check that there is data for the current year of the simulation (`time(sim)`).

-   How the fitted model object (`sdmOut`) is exported to `sim` (via `sim$sdmOut <- sdmOut`). so the model can be used by other events and inspected by the user after the simulation is finished.

## **Running the model**

### Ensuring all packages are installed

After the modules are created, we go back to the `Example2_SDMMaxent.R` script to set up and run the simulation. The first line in Code block \@ref(code:simulationPkgs) ensures that all module dependencies (and their dependencies and so on) are installed in `.libPaths`. If not it will attempt to install missing packages. Only then do we load `SpaDES` (necessary to run the simulation).

```{r simulationPkgs, eval = FALSE}
## this line can be used to make sure all packages are installed
SpaDES.install::makeSureAllPackagesInstalled(simPaths$modulePath)

## you should restart R again if any packages were installed

## load necessary packages now
library(SpaDES)
```

```{r simulationPkgsHidden, include = FALSE}
## load necessary packages now
library(SpaDES)
```

Note: `makeSureAllPackagesInstalled` may fail to install if other packages have been loaded already, so we recommend running this line from a clean R session. We also recommend restarting the R session in case `makeSureAllPackagesInstalled` does install any packages. Sometimes Windows presents problems when many packages are installed and further package installations fail. If you see errors like this:

    Installing: glue
    Detaching is fraught with many potential problems; you may have to restart your session if things aren't working
    some packages don't seem to unload their dlls correctly. These will not be unloaded: ellipsis, vctrs
    Unloading package bit64
    -- Installing glue -- (1 of 1. Estimated time left: ...; est. finish: ...calculating)
    Installing package into ‘~/R/win-library/4.0’
    (as ‘lib’ is unspecified)
    trying URL 'https://cran.rstudio.com/bin/windows/contrib/4.0/glue_1.6.2.zip'
    Content type 'application/zip' length 171858 bytes (167 KB)
    downloaded 167 KB

    package ‘glue’ successfully unpacked and MD5 sums checked
    Error in unpackPkgZip(foundpkgs[okp, 2L], foundpkgs[okp, 1L], lib, libs_only,  : 
    ERROR: failed to lock directory ‘~\R\win-library\4.0’ for modifying
    Try removing ‘~\R\win-library\4.0/00LOCK’

after restarting R, go ahead and delete the problematic file/folder and try again. Sometimes `Require` is unable to automatically install a package and a manual installation from a clean session is the only solution. For example, in the example above, `Require` only detected that `glue` was missing during the `simInit` call, which meant that other packages had been loaded already and the installation failed. This problem persisted even after we avoided loading `terra` before running `simInit` (we make the study area objects prefixing functions with `terra::`), so `glue` had to be manually installed.

### Simulation setup

The simulation folder directories were already set up before creating the modules, but it is still necessary to create a few list objects that will be passed to the `simInit` function to initialize the simulation. These define the modules used in the simulation (`simModules`), the start and end of the simulation (`simTimes`), the parameter lists passed to each module (`simParams`) and necessary external input objects (`simObjects`) like the study area (`studyAreaRas`).

We also define a few useful global options, like `reproducible.cachePath` and `reproducible.destinationPath` which determine the cache directory and where downloaded and processed data will be stored, and `reproducible.useCache` and `reproducible.useTerra` which will activate caching and the use of the `terra` package across all `Cache` and `prepInputs` function calls.

```{r simulationSetup, warning = FALSE, message = FALSE}
## a few important options:
options(reproducible.useCache = TRUE,
        reproducible.cachePath = simPaths$cachePath,
        reproducible.destinationPath = simPaths$inputPath, ## all downloaded and pre-processed layers go here
        reproducible.useTerra = TRUE)  ## we want to use the terra R package

## list the modules to use
simModules <- list("speciesAbundanceData", "climateData", "projectSpeciesDist")

## Set simulation and module parameters
simTimes <- list(start = 1, end = 2, timeunit = "year")
simParams <- list(
  "speciesAbundanceData" = list(
    ".plots" = c("screen", "png"),
    ".useCache" = c(".inputObjects", "init")
  ),
  "climateData" = list(
    ".plots" = c("screen", "png"),
    ".useCache" = c(".inputObjects", "init")
  ),
  "projectSpeciesDist" = list(
    ".plots" = c("screen", "png"),
    ".useCache" = c(".inputObjects", "init")
  )
)

## make a random study area.
##  Here use seed to make sure the same study area is always generated
studyArea <- terra::vect(SpaDES.tools::randomStudyArea(size = 1e10, seed = 123))
studyAreaRas <- terra::rasterize(studyArea, 
                                 terra::rast(extent = terra::ext(studyArea), 
                                             crs = terra::crs(studyArea, proj = TRUE), 
                                             resolution = 1000))
simObjects <- list(
  "studyAreaRas" = studyAreaRas
)

## Simulation setup
mySim <- simInit(times = simTimes, params = simParams, 
                 modules = simModules, objects = simObjects, 
                 paths = simPaths)
```

We advise having a look and the module linkage diagrams produced by `moduleDiagram` (Fig. \@ref(fig:moduleDiagram)) and `objectDiagram` (Fig. \@ref(fig:objectDiagram)) to assess whether modules are linked as expected.

```{r moduleDiagramsCode, eval = FALSE}
moduleDiagram(mySim)
objectDiagram(mySim)
```

```{r moduleDiagram, echo = FALSE, fig.align = 'center', fig.cap = "Module network diagram"}
clearPlot()
moduleDiagram(mySim)
```

```{r objectDiagram, echo = FALSE, fig.align = 'center', fig.cap = "Module diagram showing object inter-dependecies"}
objectDiagram(mySim)
```

### Simulation runs

To run the simulation, we call `spades` on the output `simList` (called `mySim` here) generated by `simInit`. We also passed the argument `debug = TRUE` so that the progress of the simulation is printed in detail. This helps diagnosing problems when the simulation fails, but also seeing what events are being executed and when particular cache calls are activated (and computations by-passed).

```{r runSimulation, eval = FALSE}
## run simulation
clearPlot(force = TRUE)   ## this forces wiping the graphics device and opening a new window
spades(mySim, debug = TRUE)
```

Try to execute the `spades` call a second time to see how much faster it runs now that many of the operations have been cached. Notice also, how the `init` events are retrieved from the cache (see [Caching]).

Here are some outputs of the model:

```{r figSimulationFig, fig.align = 'center', out.width = "50%", fig.cap = "**Simulation plots**: Raw values predictions of species probability of occurence for (left to right:) baseline climate conditions (i.e. first year of simulation) and under climate conditions projected for 2081-2100 (i.e. the second year)"}
knitr::include_graphics(c("outputs/figures/projRawVals_Year1.png", "outputs/figures/projRawVals_Year2.png"))
```

```{r figSimulationFig2, fig.align = 'center', out.width = "50%", fig.cap = "**Simulation plots**: Preditions of *Picea glauca* presences/absences for (left to right:) baseline climate conditions (i.e. first year of simulation) and under climate conditions projected for 2081-2100 (i.e. the second year"}
knitr::include_graphics(c("outputs/figures/projPA_Year1.png", "outputs/figures/projPA_Year2.png"))
```

## **Caching**

In this example, we relied on caching to avoid having to repeat computationally intensive operations. Running the `simInit` and `spades` calls twice (even after restarting R session) was much faster and `SpaDES` informed us of instances where cached objects were being retrieved:

    (...)
    Mar05 19:56:53 clmtDt 1         climateData init      1            
    Mar05 19:56:53 clmtDt   ...(Object to retrieve (a7816e2d0deb3b29.rds))
    Mar05 19:56:53 clmtDt      loaded cached result from previous Map call
    (...)

Caching in `SpaDES` is offered via the `reproducible`, and can be generally broken down into two types: explicitly coded by the module developer, or internal to `SpaDES` functions.

### Explicitly caching operations

Throughout the data modules we explicitly cached several data preparation operations using the functions `Cache` and `prepInputs` from the reproducible package. In brief, `Cache` searches for a stored (i.e. cached) output of a given function call; if it does not find it, `Cache` executes the function call and saves its output and information about the function inputs and the function's code; if it does find it, it compares the present inputs and function code against their cached counterparts. If any of them do not match, the function call is executed again and re-cached. `prepInputs` calls `Cache` internally at several points, notably to cache several spatial processing tasks (e.g. re-projecting and cropping spatial layers to a study area raster). Another great feature of `prepInputs` is that when a source URL for an object is supplied (as we did to obtain species % cover and climate layers), it checks whether the data have already been downloaded (and potentially extracted from an archive folder -- `.zip`) before doing so. This is not exactly the same think as caching, but also avoids unnecessary downloads that can be time consuming.

Note that caching operations involving stochasticity should be avoided, as it will prevent new random outputs from being generated.

We recommend exploring the examples available in the `Cache` and `prepInputs` R documentation to learn more about their capabilities. In particular, read about `showCache`, `clearCache` and the argument `userTags`, which allow consulting and deleting cached files.

**/!\\ Attention /!\\** `Cache` does not deal well with the `apply` family of functions, which is why we used `Map` (instead of `mapply`) to iteratively apply `prepInputs` to several climate layer URLs.

### Implicit caching of events

`SpaDES` offers implicit caching of events via the global parameter `.useCache`, which comes in the template modules generated by `newModule`. In addition to turning caching on/off at the module level, this parameter can control the caching of particular events. In our example, we cached data preparation events across all modules (`.inputObjects` and `init`), but not the events that fitted the SDM and generated projections. In truth, because none of the modules simulate any stochastic processes, we could have cached all events. We call this "implict" caching, because the developper does not need to add any caching mechanisms inside the module. `SpaDES` will automatically read the value of the `.useCache` parameter and activate caching in the module accordingly.

Note that loading cached events produces a slightly different message from the loading of other cached operations (above):

    Mar05 19:58:34 spcsbn 1         speciesAbundanceData init      1            
    Mar05 19:58:34 spcsbn   ...(Object to retrieve (bffbc48cc055c846.rds))
    Mar05 19:58:35 spcsbn      loaded cached copy of init event in speciesAbundanceData module.  

### Controlling caching without changing module code

In addition to the `.useCache` parameter, which controls caching at the module level. The user can turn caching on/off via two additional mechanisms:

-   via the option `options("reproducible.useCache")` -- setting this option to `TRUE` or `FALSE` in the global environment (`.GlobalEnv`) will affect *all* caching, inside and outside `SpaDES` modules.

-   via the argument `spades(.useCache = ...)` -- this argument behaves in the same way as the `.useCache` module parameter, but superceeds it across all modules (i.e. if the a module's `.useCache` is `TRUE` but `spades(..., .useCache = FALSE)`, caching will be turned off)

## **Best practices**

### Reproducible package installation

When sharing code it is good practice to provide the users with a list of necessary packages (e.g. by listing the sequence of `library` calls at the start of a script). We go a step further and advise users to provide code that automatically installs all necessary packages at the start of their controller script. In addition all modules should contain a full list of packages that they depend on, and any particular versions necessary. If `options("spades.useRequire")` is set to `TRUE` (the default), `SpaDES` will automatically attempt to install any packages listed across all modules if they are not installed in `.libPaths()`, or if the installed version (or branch if installing from GitHub) does not correspond to what is listed in the module `.R`. Users can go a step further and use the `Require::pkgSnapshot()` to save a list of installed packages that can be used later by `Require` to install all necessary packages in another machine (Code block \@ref(code:pkgSnapshot)).

Please beware that package installation should be done as much as possible from a clean R session especially in the context of a `SpaDES`-based project, where each module has several different dependencies, that have dependencies of their own (see, for instance, how we delayed package loading until after all modules were in place and had their dependencies checked in Code block \@ref(code:globalscript))

```{r pkgSnapshot, eval = FALSE}
Require::pkgSnapshot("pkgsnapshot.txt")

## on another machine:
Require::Require(packageVersionFile = "pkgsnapshot.txt")
```

See `?Require::pkgSnapshot()` for more examples.

### Protect yourself and others from common mistakes/problems

A developer should put in place code checks, warnings and messages that protect and warn the user against common mistakes or issues. Common checks are to verify that all input formats and classes conform to what the function expects. If this is not the case the developer may add a mechanism to correct the faulty inputs (potentially with a warning or message telling the user it did so) or simply stop the computations with a meaningful error. We provide an example in Code block \@ref(code:dataModule2), where the `climateInit` function executed by the `init` event of the *climateData* module. Other checks can prevent undesirable function behaviours, such as the `if` statement protecting the `newModule` call above (see Code block \@ref(code:globalscript)).

### Readable code

There are several guides as to how to write more reader-friendly code. We aim follow many of the [recommendations by Hadley Wickham](http://adv-r.had.co.nz/Style.html) some of whiche we find particularly important: \* spacing around operators \* spacing before left parenthesis, except in a function call \* adding curly braces after `if`, `else`, `for` and `function`, unless they are very short statements \* thoroughly commenting the code \* naming functions meaningfully and avoiding to re-use function names (e.g. avoid `c <- function (...) {}`, as `c` is already a `base` function)

### Module documentation (module `.Rmd`)

When modules are created using `newModule`, this function provides a template module `.Rmd` file that is meant to document the module. In this template we suggest a few key sections, notably an overview of the module, its inputs, parameters, outputs and general event flow, but also more in-depth descriptions of each of these sections. Some modules may also contain reproducible examples of how they can be used in practice, although this is not always relevant (for instance, data modules are meaningless without downstream modules that use their outputs). We invite the reader to see the manual of our forest landscape simulation model LandR Biomass_core, as an example of how we document some of our `SpaDES` modules.

### Coding for the future

We often make coding decisions that we regret a few months down the line. This is why as module developers, it is a good idea to think about other possible applications of a module or potential expansion avenues. For instance, trying to imagine if the module can be scaled up or transferred to different study areas, may influence the format of expected inputs and of outputs. In our example of the `speciesAbundanceData` we exported the same type of information in a raster layer and a `data.table`, because we could foresee that the `data.table` could be used to store several projections in a more compact format (Code block \@ref(code:dataModule1)).

### Transparent models

Model transparency is not only about using open source code and making it available. Providing easy access to model data, parameters and outputs is also important. For instance, in our example we deliberately exported the fitted statistical model `sdmOut` so that it can be more easily inspected by the user, without needing to "dive in" the code. `SpaDES` takes this a step further by offering the ability to save any objects that are exported to the `simList` object, via the `simInit(outputs = ...)` argument. To do so, the user should provide a `data.frame` of object names and the simulation times when they should be saved. Because objects are saved as `.rds` files by default, any object class can be saved to disk (see `?outputs` for more information)

------------------------------------------------------------------------

### Additional notes

`SpaDES` is an extremely powerful package, whose potential goes well beyond what has been discussed in this dummy example. If you want to explore it further, we recommend following [Example 2](https://htmlpreview.github.io/?https://github.com/CeresBarros/SpaDES4Dummies/blob/master/SpaDES4Dummies.html) for a more realistic (but still simple) `SpaDES` application.

Also, do go to the [`SpaDES` webpage](http://predictiveecology.org/) to find further information about the platform, as well as upcoming workshops and publications and to the [Predictive Ecology Github repository](http://https://github.com/PredictiveEcology/) to see all the `SpaDES` modules and SpaDES-related packages that we maintain.

------------------------------------------------------------------------

<center>

**Happy SpaDESing!**

</center>

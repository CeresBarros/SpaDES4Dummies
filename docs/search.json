[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SpaDES For Dummies",
    "section": "",
    "text": "Preface\n\n\n\nzenodoBadge\n\n\nThis guide will take you through how to make and link your own modules using SpaDES in two examples. Both examples draw on basic uses of statistical models in ecology, notably the relationships between environmental variables and species abundance and presence.\nChapter 1 is very minimal, and uses only dummy data. It is meant to introduce you to the different components of a SpaDES module.\nChapter 2 uses real and freely available data, and provides a deeper look into several useful aspects of SpaDES, notably caching and spatial data processing.\nFull R scripts to execute SpaDES workflow examples can be found in the Appendices section.\nTo install SpaDES, please have a look at SpaDES installation, or follow steps at the start of Chapter 2.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Part1_DummyModel.html#before-spades",
    "href": "Part1_DummyModel.html#before-spades",
    "title": "1  Introducing SpaDES with a dummy ecological model",
    "section": "1.1 BEFORE SpaDES",
    "text": "1.1 BEFORE SpaDES\nIf we use R to develop our species abundance and temperature simulation models in the ‘conventional way’, we’ll probably have i) (the worst case scenario) several scripts that run simulations and data treatment/analysis separately and have to be executed manually, or ii) a long script where everything happens - the simulations and data analysis -, iii) a main script that sources others that do the simulation and analyses. Option i) is more common when different software are used for different parts of the process (e.g., a simulation model in C++ generates data that is then analysed in R). Option ii) is inconvenient because very long scripts make changes and updates to the script - debugging can also be more tiresome. Option iii), is similar to the SpaDES way of thinking. The difference is that SpaDES defines a standard way of writing different components of a model, or of a modelling framework. This makes changing, updating and sharing code - or modules - easier, as well as swapping and adding modules in a modelling framework.\nThe example below is so minimal that it is unlikely to show the full benefits of using SpaDES - the same could be accomplished with a fairly short script. However, it introduces the different parts of a module and how to link modules.\nChapter 2 goes a step further and uses real datasets to project species presences across a landscape in Canada. In Chapter 2, we introduce SpaDES features that we most commonly use in our work (e.g., caching and spatial data processing) and provide some coding best practices that we use ourselves (e.g., code assertions).\n\n1.1.1 Setup\nThis is what you’d normally do… Install all the packages in some way that you probably didn’t record in your scripts and then start your script with loading the packages:\n\n\nCode\n## please start from a clean R session\nremotes::install_github(\"ropensci/NLMR\")  ## you will need this ;)\n\nlibrary(terra)\nlibrary(quickPlot)\nlibrary(ggplot2)\nlibrary(ggpubr)\n\n\nAnd now create a raster template:\n\n\nCode\nr &lt;- rast(nrows = 100, ncols = 100, xmin = -50, xmax = 50, ymin = -50,\n    ymax = 50)\n\n\n\n\n1.1.2 Species abundance “simulations”\nOur VERY simple “simulation” model (in form of a function) generates rasters that follow a Gaussian distribution\n\n\nCode\nabundance_model &lt;- function(ras, Time) {\n    abund_outputs &lt;- list()\n    for (t in 1:Time) {\n        abund_outputs[[t]] &lt;- NLMR::nlm_mpd(ncol = ncol(ras),\n            nrow = nrow(ras), resolution = unique(res(ras)),\n            roughness = 0.5, rand_dev = 100, rescale = TRUE,\n            verbose = FALSE) |&gt;\n            rast()\n    }\n    return(abund_outputs)\n}\n\n\nSet the length of the simulation (or simply the number of model iterations), run it and plot results (all ABUNDANCE plots together):\n\n\nCode\nTime &lt;- 10\nabundance &lt;- abundance_model(ras = r, Time = Time)\ndev()\nplot(rast(abundance))\n\n\n\n\n\n\n\n\n\n\n\n1.1.3 Temperature “simulations”\nThe temperature simulation model will be similar to the vegetation one - remember this is a dummy example.\n\n\nCode\ntemperature_model &lt;- function(ras, Time) {\n    temp_outputs &lt;- list()\n    for (t in 1:Time) {\n        temp_outputs[[t]] &lt;- NLMR::nlm_mpd(ncol = ncol(ras),\n            nrow = nrow(ras), resolution = unique(res(ras)),\n            roughness = 0.5, rand_dev = 10, rescale = FALSE,\n            verbose = FALSE) |&gt;\n            rast()\n    }\n    return(temp_outputs)\n}\n\n\nRun the model and plot results (all temperature plots together)\n\n\nCode\ntemperature &lt;- temperature_model(ras = r, Time = Time)\nplot(rast(temperature))\n\n\n\n\n\n\n\n\n\n\n\n1.1.4 Data analysis\nNow we analyse if species abundance and temperature are correlated.\n\nFirst, we create the data analysis function (a simple linear model):\n\n\nCode\nstats_analysis &lt;- function(Data) {\n    if (all(c(\"abund\", \"temp\") %in% colnames(Data))) {\n        lm1 &lt;- lm(abund ~ temp, data = Data)\n        ggplot(Data) + geom_point(aes(x = temp, y = abund)) +\n            geom_abline(intercept = lm1$coefficients[\"(Intercept)\"],\n                slope = lm1$coefficients[\"temp\"], size = 2, col = \"blue\") +\n            theme_bw() + labs(x = \"Temp.\", y = \"Species abundance\")\n\n    } else {\n        stop(\"Data must contain 'abund' and 'temp' columns\")\n    }\n}\n\n\nThen we create a loop to analyse each plot of our time-series:\n\n\nCode\nlmPlots &lt;- list()\nfor (t in 1:Time) {\n    outputdata &lt;- data.frame(abund = as.vector(abundance[[t]][]),\n        temp = as.vector(temperature[[t]][]))\n    lmPlots[[t]] &lt;- stats_analysis(Data = outputdata)\n}\n## Warning: Using `size` aesthetic for lines was deprecated in ggplot2\n## 3.4.0.\n## ℹ Please use `linewidth` instead.\nggarrange(plotlist = lmPlots)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing `SpaDES` with a dummy ecological model</span>"
    ]
  },
  {
    "objectID": "Part1_DummyModel.html#after-spades",
    "href": "Part1_DummyModel.html#after-spades",
    "title": "1  Introducing SpaDES with a dummy ecological model",
    "section": "1.2 AFTER SpaDES",
    "text": "1.2 AFTER SpaDES\n\n1.2.1 The control script\nLet us now solve the same problem using the SpaDES approach.1 We start by creating an .R script (it can have any name) that sets up and runs the SpaDES model. The control script for this example is located on the root of the SpaDES4Dummies GitHub repository under the name Part1_DummyModel.R. Note that Markdown (.Rmd) scripts can also be used instead of `.R` scripts.\nWe start by making sure all SpaDES packages and their dependencies are installed (and that the installation is scripted) using the Require package.\n\n\nCode\n## start again from a clean R session\noptions(repos = c(\"https://predictiveecology.r-universe.dev/\",\n    CRAN = \"https://cloud.r-project.org\"))\n\n## decide where you're working\nmainPath &lt;- \"~/SpaDES4Dummies_Part1\"\npkgPath &lt;- file.path(mainPath, \"packages\", version$platform,\n    paste0(version$major, \".\", strsplit(version$minor, \"[.]\")[[1]][1]))\ndir.create(pkgPath, recursive = TRUE)\n.libPaths(pkgPath, include.site = FALSE)  ## install packages in project library (proj-lib)\n\nif (!\"remotes\" %in% installed.packages(lib.loc = pkgPath)) install.packages(\"remotes\")\n\nif (!\"Require\" %in% installed.packages(lib.loc = pkgPath) ||\n    packageVersion(\"Require\", lib.loc = pkgPath) &lt; \"0.3.1.9015\") {\n    remotes::install_github(\"PredictiveEcology/Require@2788b023ad191c29346ef8c64df71b937be307e2\",\n        upgrade = FALSE)\n}\n\nRequire::Require(c(\"SpaDES\", \"DiagrammeR\"), require = FALSE,\n    upgrade = FALSE, dependencies = TRUE, standAlone = TRUE)  ## automatically downloads all packages in the SpaDES family and their dependencies\n\nlibrary(SpaDES)\n\nsetPaths(cachePath = file.path(mainPath, \"cache\"), inputPath = file.path(mainPath,\n    \"inputs\"), modulePath = file.path(mainPath, \"modules\"), outputPath = file.path(mainPath,\n    \"outputs\"))\n\ngetPaths()  ## check that this is what you wanted\n\n## Let's create a self-contained module that will simulate\n## the species' abundance for any given period of time and\n## frequency.\nif (!dir.exists(file.path(getPaths()$modulePath, \"speciesAbundance\"))) {\n    newModule(name = \"speciesAbundance\", path = getPaths()$modulePath)\n}\n\n\nWe then create modules using newModule. newModule creates a module folder (speciesAbundance) inside /modules that contains both the module .R script template, as well as the documentation template (the .Rmd file). Although we will not be discussing the .Rmd file, please bear in mind that this is a fundamental part of creating a reproducible and transparent module - check out the Guide to Reproducible Code in Ecology and Evolution from the British Ecological Society). The documentation should contain a the description of the module, its input, parameters and outputs, and potentially a reproducible examples of how the module is executed.\nnewModule also created the folder /data where data necessary to the module can be put in, and the folder /tests that may contain testing scripts. We will not be using either of them in this example.\n/!\\ ATTENTION /!\\\nnewModule should only be run once, otherwise it will replace all edits and contents of the module folder with the templates - this is why it is wrapped in an if statement above.\nNow go ahead, open the speciesAbundance.R script and have a look at it.\n\n\n\n1.2.2 General module structure: speciesAbundance module\nThe module template contains all the essential components of a module, with examples, and may seem overwhelming at first. We’ll go through it step by step (although not necessarily following the order of the script). The module script can be divided into 4 parts:\nDefining the module: this is where the module is defined, i.e., the module’s metadata (e.g. module author(s), time units, basic parameters, general inputs and outputs, etc.);\nEvents and event functions: these are the “actions” (or events) executed in the module (i.e. species reproduction, plotting, saving parameters) - simply put, WHAT the module does;\nScheduling events: this is how SpaDES schedules when each event is going to happen - in which order (e.g. during the simulation, when will SpaDES plot a graph) - simply put, WHEN the module does it;\nAdditional module functions: any additional functions needed (e.g. this is used to keep the coding of your module as clear and straightforward as possible);\nThe first thing to note is that the user does not need to manually run any of the code inside a module’s .R script. The function simInit() will do so when it sets up the simulation. We will see this see this later in detail.\n\n1.2.2.1 Defining the module\nThe first section of the script defines the module’s metadata. It allows defining the module’s author, keywords, any required packages and module(s) and their versions, but also parameters (and their default values) and input objects that the module requires, and the output objects it creates.\nAlthough this dummy module example requires no true input data, we will define the template raster `r` as an “input” in the expectsInput function, and provide a default object in .inputObjects (see below). As for the outputs, it produces a list of abundance rasters (produced during the abundanceSim event). So we define it as an output in thecreatesOutput function.\nNote that we removed several parameters that come with the template created by the newModule function, as they are not needed for this example.\nTo distinguish what input and output objects are in the context of a module, a good rule of thumb is that inputs are all the sim$... objects that appear for the first time (in the module events) on the right-hand side of a &lt;-, whereas output parameters are the sim$... objects that appear for the first time to the left-hand side of a &lt;-. Another way of explaining it for objects is illustrated in Figure 1.1 :\n\n\n\n\n\n\n\n\nFigure 1.1: Inputs and outputs in SpaDES: Object A comes from outside of the module (e.g. from an internet URL, from data you have, or from .inputObjects), while Module Z produces object C. Both objects serve as an inputs for Module Y, which in return produce as outputs objects B and D, respectivelly from objects A and C. As Module Z uses a simple function internally to create object C, it doesn’t have any inputs, such as our dummy example.\n\n\n\n\n\nThe default input objects created by the .inputObjects function (see [.inputObjects function]) during the simInit call are exceptions to this rule.\nHere is how we defined the speciesAbundance module:\n\n\nCode\ndefineModule(sim, list(\n  name = \"speciesAbundance\",\n  description = \"\",\n  keywords = \"\",\n  authors = person(\"Me\", email = \"me@example.com\", role = c(\"aut\", \"cre\")),\n  childModules = character(0),\n  version = list(speciesAbundanceData = \"1.0.0\"),\n  timeframe = as.POSIXlt(c(NA, NA)),\n  timeunit = \"year\",\n  citation = list(\"citation.bib\"),\n  documentation = deparse(list(\"README.txt\", \"speciesAbundance.Rmd\")),\n  reqdPkgs = list(\"SpaDES.core (&gt;=2.0.2)\",\n                  \"terra\", \"quickPlot\"),\n  parameters = bindrows(\n    #defineParameter(\"paramName\", \"paramClass\", value, min, max, \"parameter description\"),\n    defineParameter(\"simulationTimeStep\", \"numeric\", 1, NA, NA, \n                    \"This describes the simulation time step interval\"),\n    defineParameter(\".plotInitialTime\", \"numeric\", 1, NA, NA,\n                    \"Describes the simulation time at which the first plot event should occur.\"),\n    defineParameter(\".plotInterval\", \"numeric\", 1, NA, NA,\n                    \"Describes the simulation time interval between plot events.\")\n  ),\n  inputObjects = bindrows(\n    # expectsInput(\"objectName\", \"objectClass\", \"input object description\", sourceURL, ...),\n    expectsInput(\"r\", objectClass = \"SpatRaster\", desc = \"Template raster\")\n  ),\n  outputObjects = bindrows(\n    #createsOutput(\"objectName\", \"objectClass\", \"output object description\", ...),\n    createsOutput(\"abundRasters\", \"list\", \"List of layers of species abundance at any given year\")\n  )\n))\n\n\nNote that the package versions that you define will depend on the ones that are installed on your computer. So take care to change them accordingly. The SpaDES package version suggested by the template reflects the version on your computer.\nThe rest of the script defines the events and their sequences for this module - remember SpaDES = Spatial Discrete Event Simulator - and the events themselves.\n/!\\ ATTENTION /!\\\ndefineModule() is not intended to be run directly by the user – it is run internally during a simInit() call (see Simulation setup in a “global” script). In other words, you don’t run any part of a module’s code directly in your session; you run simInit() with that module listed in the modules argument.\n\n\n1.2.2.2 Events and event functions\nModule events are defined and scheduled in the doEvent.&lt;module name&gt; function (in this example, doEvent.speciesAbundance function; see [Scheduling events]. Since we are only interested in simulating and plotting species abundances, we removed unnecessary events from the script and kept: the initialisation (init), an abundance simulation event (SimulAbund) and a plotting event (abundPlot). Each of these events can execute one or more functions.\nEvent functions (actual R functions) mustn’t be confused with event names, which are the names of the events appearing in the doEvent.&lt;module name&gt;.\n/!\\ ATTENTION /!\\\nEvent functions take only one argument, sim (the SpaDES.core::simList object that stores all objects, modules, functions, etc., of a simulation; see ?simList) and event functions always (and only) return sim (using return(invisible(sim))).\n\n1.2.2.2.1 Initialisation event function\nThe initialisation event function (here, abundanceInit) can be seen as the starting point of the module. Unlike the init event, which must always be present, the function itself does not need to exist (see [Scheduling events]) and can have whatever name we want.\nUsually, this function will does pre-simulation steps that are only need to be executed once. In our dummy example, it creates a template raster and a storage list for our species abundance outputs (which will also be rasters). Notice that the only argument to abundanceInit is sim, a simList object that is also its only output.\n\n\nCode\nabundanceInit &lt;- function(sim) {\n    ## create storage list of species abundance\n    sim$abundRasters &lt;- list()\n\n    return(invisible(sim))\n}\n\n\n\n\n1.2.2.2.2 Abundance simulation event function\nThe function abundanceSim is the core event function of this module, where species abundances are generated via the event. Notice how instead of a for-loop, abundanceSim runs the abundance_model function (which we define separately below) and stores its outputs in the sim$abundRaster object. Notice as well that we use time(sim) as the identifier of the list slots where outputs are stored (see ?SpaDES.core::time).\nAs before, the sole argument and output to this event function is the sim object.\n\n\nCode\nabundanceSim &lt;- function(sim) {\n    ## Generate species abundances - our 'simulation'\n    sim$abundRasters[[as.character(time(sim))]] &lt;- abundance_model(ras = sim$r)\n\n    return(invisible(sim))\n}\n\n\nThe abundanceSim function was called Event1 in the template.\n\n\n1.2.2.2.3 Plotting event function\nFinally, we created the abundancePlot event function to plot the species abundance rasters that are produced by the abundanceSim event function. Again, the sole argument and output of this function is sim.\n\n\nCode\nabundancePlot &lt;- function(sim) {\n    ## plot abundances\n    plotTitle &lt;- paste(\"Species abundance\\nat time\", names(sim$abundRasters)[length(sim$abundRasters)])\n    abundPlot &lt;- sim$abundRasters[[length(sim$abundRasters)]]\n    Plot(abundPlot, title = plotTitle, new = TRUE, addTo = \"abundPlot\")\n\n    return(invisible(sim))\n}\n\n\nThe abundancePlot function was called plotFun in the template.\n\n\n\n1.2.2.3 Scheduling events\nThe order in which module events are executed is determined by the doEvent.&lt;module name&gt; function. This function also defines the events themselves and what happens in them. The switch function executes each event (here init, SimulAbund, and abundPlot) and the events schedule themselves. Two things are of particular importance:\n\nThe init event is mandatory. This is the only event whose name that cannot be changed and that cannot be removed (even if it does not execute any event functions). All other events are optional and can be renamed. SpaDES searches and executes all modules’ init events automatically. Note that the names of event functions executed during init can have any name: here we changed the Init function name (suggested by the template) to abundanceInit.\nEvents should only schedule themselves. The only exception is the init, which schedules the first time all other events are executed (even if a particular event only occurs once at the end of the simulation).\n\nIt is usually easier to fill the doEvent.&lt;module name&gt; function after having defined the event functions (as we did above). For instance, we know that plotting should occur after the generation of species abundances, and so the abundPlot will be scheduled to occur after the SimulAbund event, by changing event priority (see ?priority).\nThis is how we configured our doEvent.speciesAbundance function:\n\n\nCode\ndoEvent.speciesAbundance = function(sim, eventTime, eventType,\n    debug = FALSE) {\n    switch(eventType, init = {\n        ## do stuff for this event\n        sim &lt;- abundanceInit(sim)\n\n        ## schedule future event(s)\n        sim &lt;- scheduleEvent(sim, eventTime = start(sim), moduleName = \"speciesAbundance\",\n            eventType = \"SimulAbund\")\n        sim &lt;- scheduleEvent(sim, eventTime = P(sim)$.plotInitialTime,\n            moduleName = \"speciesAbundance\", eventType = \"abundPlot\",\n            eventPriority = .normal() + 0.5)\n    }, SimulAbund = {\n        ## do stuff for this event\n        sim &lt;- abundanceSim(sim)\n\n        ## schedule future event(s)\n        sim &lt;- scheduleEvent(sim, eventTime = time(sim) + P(sim)$simulationTimeStep,\n            moduleName = \"speciesAbundance\", eventType = \"SimulAbund\")\n    }, abundPlot = {\n        ## do stuff for this event\n        sim &lt;- abundancePlot(sim)\n\n        ## schedule future event(s)\n        sim &lt;- scheduleEvent(sim, eventTime = time(sim) + P(sim)$.plotInterval,\n            moduleName = \"speciesAbundance\", eventType = \"abundPlot\",\n            eventPriority = .normal() + 0.5)\n    }, warning(paste(\"Undefined event type: '\", current(sim)[1,\n        \"eventType\", with = FALSE], \"' in module '\", current(sim)[1,\n        \"moduleName\", with = FALSE], \"'\", sep = \"\")))\n    return(invisible(sim))\n}\n\n\nWe suggest having a look at ?base::switch too fully understand its behaviour. In short, base::switch tells R to execute (or switch) different code depending on the value of EXPR (here eventType). Here, this means that the behaviour of the function doEvent.speciesAbundance will change depending on the present eventType. So we need to define what behaviour it should have for each event type defined in the module - namely, which functions will be executed and whether to schedule future events with scheduleEvent.\n\n1.2.2.3.1 init\nThe first event is, obviously, init - again its name cannot be changed.\nIn init we run the initialisation event function (abundanceInit) - optional - and schedule the first occurrence of all other events (here, the abundance simulation, SimulAbund, and plotting, abundPlot, events). Because the init is the only event that SpaDES always executes at the start of the simulation, if no events are scheduled during init, no events will be executed after the init. Notice two things:\n\nThe SimulAbund event is scheduled at start(sim) (i.e. at the first time step of the simulation), which means that it will run after the init event, but still in the same “year”.\ninit schedules the first plotting event to be executed at the time defined by the .plotInitialTime parameter, which is stored in the sim object (and obtained using SpaDES.core::P(sim)), but with a slightly lower event priority eventPriority = .normal()+0.5 (see ?priority).\n\n\n\n1.2.2.3.2 SimulAbund\nThe SimulAbund event is defined next. This event used to be called event1 in the template, and we changed its name to be more informative of what it does. It is the core event of this module, where species abundances are generated via the event function abundanceSim.\nThe even also schedules itself to occur at a frequency defined by the simulationTimeStep parameter\n\n\n1.2.2.3.3 abundPlot\nFinally, we schedule the plotting event, abundPlot (which used to be called plot in the template). Similarly to the SimulAbund event, it executes an event function (abundancePlot) and reschedules itself. An important difference is that it uses the .plotInterval parameter, instead of simulationTimeStep, when rescheduling itself. This way, future events will occur depending on the time step and plot interval parameters defined in the global script (or their default values defined in the metadata section).\n\n\n\n1.2.2.4 .inputObjects function\nThe end of the template .R script defines a function called .inputObjects. This is where the developer should include code to provide the defaults for any input objects required by the module. This is the ideal place to produce the template raster, r , instead of doing so in abundanceInit. This will allow a future user (or module) to provide their own r object (e.g. for another study area). If on the other hand we don’t do this and create r during the init event, any r supplied by the user will be overridden by the execution of init.\nAs a rule of thumb, default inputs should be created in a way that allows their values to be overridden by the user (by supplying a named list of objects via simInit(objects = ...)) or by any other modules that produce these objects. For this, we rely on the SpaDES.core::suppliedElsewhere function, which detects if a given object has already been supplied by the user or if it will be supplied by another module.\nNote that suppliedElsewhere does not know whether the module that supplies the object will be executed before the present module, as it is blind to module scheduling order. When modules are relatively simple and have an approximately linear flow of interdependencies, SpaDES is usually able to tell the order in which modules need to be executed. In more complex cases it is a good idea to pass a vector of module names to simInit(loadOrder = ...) definining the order of module execution.\nHere’s an example of how to do this (the commented instructions have been deleted):\n\n\nCode\n.inputObjects &lt;- function(sim) {\n    if (!suppliedElsewhere(\"r\")) {\n        ## make template raster if not supplied elsewhere.\n        sim$r &lt;- rast(nrows = 100, ncols = 100, xmin = -50, xmax = 50,\n            ymin = -50, ymax = 50)\n    }\n    return(invisible(sim))\n}\n\n\nIf we choose to supply the default r in .inputObjects, then we need to remove its creation from the abundanceInit function and add r to the metadata as an input. We have done this, so that abundanceInit only creates a storage list for the outputs:\n\n\nCode\nabundanceInit &lt;- function(sim) {\n    ## create storage list of species abundance\n    sim$abundRasters &lt;- list()\n\n    return(invisible(sim))\n}\n\n\nIt is good practice to provide default input objects to all remaining modules, so that they can work stand-alone. We have done this below.\n/!\\ ATTENTION /!\\\nIf r becomes an input with defaults it must be added to the module metadata inside an expectsInput call.\n\n\n1.2.2.5 Additional module functions\nEvents can also rely on other functions that can either be sourced from other scripts, or defined at the end of the module script (e.g. usually before .inputObjects, although the order is irrelevant). This is the case for the species abundances generator function, which we coded in a separate script called abundance_model.R. Scripts with accessory functions like these go into module’s R/ folder.\nFunctions should also be accompanied by metadata. Here we provide a description of the function, its parameters, returning value and what other package functions it relies on using the roxygen2 documentation style (indicated by #').\n\n\nCode\n#' Accessory function to speciesAbundance module\n#' \n#' @param ras a raster layer used as template.\n#' @return a fake abundance SpatRaster generated as a Gaussian map with scale = 100 and variance = 0.01\n#' @importFrom NLMR nlm_mpd\n#' @importFrom terra rast\nabundance_model &lt;- function(ras) {\n    abund_ras &lt;- NLMR::nlm_mpd(ncol = ncol(ras), nrow = nrow(ras),\n        resolution = unique(res(ras)), roughness = 0.5, rand_dev = 100,\n        rescale = TRUE, verbose = FALSE) |&gt;\n        rast()\n    return(abund_ras)\n}\n\n\n\n\n\n\n1.2.3 Creating and adding additional modules: the temperature module\nThe order in which modules are first executed (i.e. their init events) can be automatically determined by inter-module dependencies (i.e. module inputs that are the outputs of other modules). If there are no inter-module dependencies this order is determined by the order in which the modules are listed in the Part1_DummyModel.R script, or via the simInit(loadOrder = ...) argument.\nAfter the init event, the module execution order follows the order of events. This means that a module’s events can be scheduled before and after another module’s events within the same simulation time step. However, keep in mind that this can make the simulation flow hard to follow, debug and change when additional modules are added.\nThe second module we created generates yearly temperatures. Apart from different objects and functions names, this module also has the template raster r as required input object. Recall that r is created during the .inputObjects of the speciesAbundance module. When the two modules are linked, this object will not be created twice because suppliedElsewhere(\"r\") will tell the temperature module that `r` will be supplied by another module. This may appear trivial in this example, but it can be extremely useful when inuts are heavy objects that require lengthy computations to be produces.\nThis is how we set up the temperature.R script looks like:\n\n\nCode\n\n# Everything in this file gets sourced during simInit, and all functions and objects\n# are put into the simList.\ndefineModule(sim, list(\n  name = \"temperature\",\n  description = \"Temperature simulator\",\n  keywords = c(\"temperature\", \"gaussian\", \"spatial\"),\n  authors = structure(list(list(given = c(\"Ceres\"), family = \"Barros\", \n                                role = c(\"aut\", \"cre\"), email = \"ceres.barros@ubc.ca\", comment = NULL)), class = \"person\"),\n  childModules = character(0),\n  version = list(temperature = \"1.0.0\"),\n  timeframe = as.POSIXlt(c(NA, NA)),\n  timeunit = \"year\",\n  citation = list(\"citation.bib\"),\n  documentation = list(\"README.txt\", \"temperature.Rmd\"),\n  reqdPkgs = list(\"SpaDES.core (&gt;=2.0.2)\",\n                  \"terra\", \"ropensci/NLMR\"),\n   parameters = bindrows(\n    #defineParameter(\"paramName\", \"paramClass\", value, min, max, \"parameter description\"),\n    defineParameter(\"simulationTimeStep\", \"numeric\", 1, NA, NA, \n                    \"This describes the simulation time step interval\"),\n    defineParameter(\".plotInitialTime\", \"numeric\", 1, NA, NA, \n                    \"This describes the simulation time at which the first plot event should occur\"),\n    defineParameter(\".plotInterval\", \"numeric\", 1, NA, NA,\n                    \"This describes the simulation time interval between plot events\")\n  ),\n  inputObjects = bindrows(\n    #expectsInput(\"objectName\", \"objectClass\", \"input object description\", sourceURL, ...),\n    expectsInput(\"r\", \"SpatRaster\", \"Template raster\")\n  ),\n  outputObjects = bindrows(\n    #createsOutput(\"objectName\", \"objectClass\", \"output object description\", ...),\n    createsOutput(\"tempRasters\",  \"list\", \"List of raster layers of temperature at any given year\")\n  )\n))\n\n## event types\n#   - type `init` is required for initialiazation\n\ndoEvent.temperature = function(sim, eventTime, eventType, debug = FALSE) {\n  switch(\n    eventType,\n    init = {\n      ## do stuff for this event\n      sim &lt;- Init(sim)\n      \n      ## schedule future event(s)\n      sim &lt;- scheduleEvent(sim, eventTime = start(sim), moduleName = \"temperature\", eventType = \"SimulTemp\")\n      sim &lt;- scheduleEvent(sim, eventTime = P(sim)$.plotInitialTime, moduleName = \"temperature\", \n                           eventType = \"tempPlot\", eventPriority = .normal() + 0.5)\n    },\n    SimulTemp = {\n      ## do stuff for this event\n      sim &lt;- update(sim)\n      \n      ## schedule future event(s)\n      sim &lt;- scheduleEvent(sim, eventTime = time(sim) + P(sim)$simulationTimeStep, moduleName = \"temperature\", \n                           eventType = \"SimulTemp\")\n    },\n    tempPlot = {\n      ## do stuff for this event\n      sim &lt;- plotting(sim)\n      \n      ## schedule future event(s)\n      sim &lt;- scheduleEvent(sim, eventTime = time(sim) + P(sim)$.plotInterval, moduleName = \"temperature\", \n                           eventType = \"tempPlot\", eventPriority = .normal() + 0.5)\n    },\n    warning(paste(\"Undefined event type: '\", current(sim)[1, \"eventType\", with = FALSE],\n                  \"' in module '\", current(sim)[1, \"moduleName\", with = FALSE], \"'\", sep = \"\"))\n  )\n  return(invisible(sim))\n}\n\n## This is the 'init' event:\nInit &lt;- function(sim) {\n  ## create storage list of species temperature\n  sim$tempRasters &lt;- list()\n  \n  return(invisible(sim))\n}\n\n## This is the temperature simulation event function\nupdate &lt;- function(sim) {\n  ## Generate temperature - our \"updated data\"\n  sim$tempRasters[[as.character(time(sim))]] &lt;- temperature_model(ras = sim$r)\n  \n  return(invisible(sim))\n}\n\n## This is the plotting event funciton\nplotting &lt;- function(sim) {\n  ## plot temperature\n  plotTitle &lt;- paste(\"Temperature\\nat time\",\n                     names(sim$tempRasters)[length(sim$tempRasters)])\n  tempPlot &lt;- sim$tempRasters[[length(sim$tempRasters)]] \n  Plot(tempPlot, \n       title = plotTitle, \n       new = TRUE, addTo = \"tempPlot\")\n  \n  return(invisible(sim))\n}\n\n.inputObjects &lt;- function(sim) {\n  if (!suppliedElsewhere(\"r\")) {\n    ## make template raster if not supplied elsewhere.\n    sim$r &lt;- rast(nrows = 100, ncols = 100, xmin = -50, xmax = 50, ymin = -50, ymax = 50)\n  }\n  return(invisible(sim))\n}\n\n\nAgain, we added an accessory temperature_model function in a separate script R/temperature_model.R:\n\n\nCode\n#' Accessory function to temperature module\n#' \n#' @param ras a raster layer used as template.\n#' @return a fake temperature SpatRaster generated as a Gaussian map with scale = 100 and variance = 0.01\n#' @importFrom NLMR nlm_mpd\n#' @importFrom terra rast\ntemperature_model &lt;- function(ras) {\n    temp_ras &lt;- NLMR::nlm_mpd(ncol = ncol(ras), nrow = nrow(ras),\n        resolution = unique(res(ras)), roughness = 0.5, rand_dev = 10,\n        rescale = FALSE, verbose = FALSE) |&gt;\n        rast()\n    return(temp_ras)\n}\n\n\n\n\n\n1.2.4 Modules that depend on other modules: the speciesTempLM module\nOur third and last module, speciesTempLM, will be used to run the statistical analysis at each year, after the abundances and temperatures are generated (species and Temperature Linear Model). Hence, it will depend on the outputs of the speciesAbundance and the temperature modules.\nThe interest of keeping the statistical analysis in a separate module lies on the fact that it allows us to easily swap and compare different statistical models to analyse our data if we want to.\nIt also allows for greater flexibility when it comes to when the statistical model is supposed to run. For example, we may want to fit it at every 5 years, instead of every year, using the previous 5 years of data. By having the statistical analysis contained in its own module, we don’t need to change other module scripts in order to make these changes.\nFinally, we draw your attention to a few differences in this module’s script before we see it:\n\nThe frequency of the statistical analysis (and correspondent plots) will be determined by the parameter statsTimestep. This parameter also determines the number of data years to be used to fit the linear model. If statsTimestep = 5, the statistical analysis will use the precedent 5 years of data including the year in which the event is running (a total of 6 years of data);\nThis module requires inputs that have no defaults in .inputObjects. They are specified in inputObjects part of defineModule - notice how we’ve respected the names, classes and description of the objects that come from the speciesAbundance and the temperature modules;\nWe have two additional functions in a separate script (R/linear_model_functions.R): the function fitting the linear model and a plotting function.\n\nBelow is the full module script. Notice how the future events where scheduled to P(sim)$statsTimestep + 0.1, to force the statistical analyses to occur after the abundance and temperature rasters are ready.\n\n\nCode\n\n# Everything in this file gets sourced during simInit, and all functions and objects\n# are put into the simList.\ndefineModule(sim, list(\n  name = \"speciesTempLM\",\n  description = \"Statistical analysis of species ~ temperature relationships using LM\",\n  keywords = c(\"linear model\"),\n  authors = structure(list(list(given = c(\"Ceres\"), family = \"Barros\", \n                                role = c(\"aut\", \"cre\"), email = \"ceres.barros@ubc.ca\", comment = NULL)), class = \"person\"),\n  childModules = character(0),\n  version = list(speciesTempLM = \"1.0.0\"),\n  timeframe = as.POSIXlt(c(NA, NA)),\n  timeunit = \"year\",\n  citation = list(\"citation.bib\"),\n  documentation = list(\"README.txt\", \"speciesTempLM.Rmd\"),\n  reqdPkgs = list(\"SpaDES.core (&gt;=2.0.2)\",\n                  \"terra\", \"ggplot2\", \"data.table\", \"reshape2\"),\n   parameters = bindrows(\n    #defineParameter(\"paramName\", \"paramClass\", value, min, max, \"parameter description\"),\n    defineParameter(\"statsTimestep\", \"numeric\", 1, NA, NA, \"This describes the how often the statitiscal analysis will be done\")\n  ),\n  inputObjects = bindrows(\n    #expectsInput(\"objectName\", \"objectClass\", \"input object description\", sourceURL, ...),\n    expectsInput(\"abundRasters\", \"list\", \"List of raster layers of species abundance at any given year\"),\n    expectsInput(\"tempRasters\", \"list\", \"List of raster layers of temperature at any given year\")\n  ),\n  outputObjects = bindrows(\n    #createsOutput(\"objectName\", \"objectClass\", \"output object description\", ...),\n    createsOutput(\"outputdata\", \"list\", \"List of dataframes containing species abundances and temperature values per pixel\"),\n    createsOutput(\"outputLM\", \"list\", \"List of output yearly LMs (abundance ~ temperature)\"),\n    createsOutput(\"yrs\", \"numeric\", \"Vector of years used for statistical analysis\")\n  )\n))\n\n## event types\n#   - type `init` is required for initialiazation\n\ndoEvent.speciesTempLM = function(sim, eventTime, eventType, debug = FALSE) {\n  switch(\n    eventType,\n    init = {\n      ## do stuff for this event\n      sim &lt;- statsInit(sim)\n\n      ## schedule future event(s)\n      sim &lt;- scheduleEvent(sim, P(sim)$statsTimestep, \"speciesTempLM\", \n                           \"stats\", eventPriority = .normal() + 2)\n      sim &lt;- scheduleEvent(sim, P(sim)$statsTimestep, \"speciesTempLM\", \n                           \"statsPlot\", eventPriority = .normal() + 2.5)\n    },\n    stats = {\n      ## do stuff for this event\n      sim &lt;- statsAnalysis(sim)\n      \n      ## schedule future event(s)\n      sim &lt;- scheduleEvent(sim, time(sim) + P(sim)$statsTimestep, \"speciesTempLM\", \n                           \"stats\", eventPriority = .normal() + 2)\n    },\n    statsPlot = {\n      ## do stuff for this event\n      sim &lt;- statsPlot(sim)\n      \n      ## schedule future event(s)\n      sim &lt;- scheduleEvent(sim, time(sim) + P(sim)$statsTimestep, \"speciesTempLM\",\n                           \"statsPlot\", eventPriority = .normal() + 2.5)\n    },\n    warning(paste(\"Undefined event type: '\", current(sim)[1, \"eventType\", with = FALSE],\n                  \"' in module '\", current(sim)[1, \"moduleName\", with = FALSE], \"'\", sep = \"\"))\n  )\n  return(invisible(sim))\n}\n\n## template initialization\nstatsInit &lt;- function(sim) {\n  ## create outputs storage lists\n  sim$outputLM &lt;- list()\n  \n  return(invisible(sim))\n}\n\n## Statistical analysis event\nstatsAnalysis &lt;- function(sim) {\n  ## get all species abundances data available\n  abundData &lt;- as.data.table(rast(sim$abundRasters))\n  abundData[, pixID := 1:nrow(abundData)]\n  abundData &lt;- melt.data.table(abundData, id.var = \"pixID\",\n                               variable.name = \"year\", value.name = \"abund\")\n  abundData[, year := as.numeric(sub(\"X\", \"\", year))]\n  \n  ## get all temperature data available\n  tempData &lt;- as.data.table(rast(sim$tempRasters))\n  tempData[, pixID := 1:nrow(tempData)]\n  tempData &lt;- melt.data.table(tempData, id.var = \"pixID\",\n                              variable.name = \"year\", value.name = \"temp\")\n  tempData[, year := as.numeric(sub(\"X\", \"\", year))] \n  \n  ## merge per year  \n  setkey(abundData, pixID, year)\n  setkey(tempData, pixID, year)\n  sim$outputdata &lt;- abundData[tempData]\n  \n  sim$outputLM[[as.character(time(sim))]] &lt;- linearModel(Data = sim$outputdata)\n  return(invisible(sim))\n}\n\n## Plotting event\nstatsPlot &lt;- function(sim) {\n  model &lt;- sim$outputLM[[as.character(time(sim))]]\n  \n  modelPlot &lt;- ggplot(sim$outputdata) + \n    geom_point(aes(x = temp, y = abund)) +\n    geom_abline(intercept = model$coefficients[\"(Intercept)\"], \n                slope = model$coefficients[\"temp\"], size = 2, col = \"blue\") +\n    theme_bw() +\n    labs(x = \"Temp.\", y = \"Species abundance\")\n  \n  plotTitle &lt;- paste(\"abundance ~ temperature\\n\",\n                     \"years\", range(sim$outputdata$year)[1],\n                     \"to\", range(sim$outputdata$year)[2])\n  Plot(modelPlot, \n       title = plotTitle, \n       new = TRUE, addTo = \"modelPlot\")\n  \n  return(invisible(sim))\n}\n\n.inputObjects &lt;- function(sim) {\n  # Any code written here will be run during the simInit for the purpose of creating\n  # any objects required by this module and identified in the inputObjects element of defineModule.\n  # This is useful if there is something required before simulation to produce the module\n  # object dependencies, including such things as downloading default datasets, e.g.,\n  # downloadData(\"LCC2005\", modulePath(sim)).\n  # Nothing should be created here that does not create a named object in inputObjects.\n  # Any other initiation procedures should be put in \"init\" eventType of the doEvent function.\n  # Note: the module developer can check if an object is 'suppliedElsewhere' to\n  # selectively skip unnecessary steps because the user has provided those inputObjects in the\n  # simInit call, or another module will supply or has supplied it. e.g.,\n  # if (!suppliedElsewhere('defaultColor', sim)) {\n  #   sim$map &lt;- Cache(prepInputs, extractURL('map')) # download, extract, load file from url in sourceURL\n  # }\n  \n  #cacheTags &lt;- c(currentModule(sim), \"function:.inputObjects\") ## uncomment this if Cache is being used\n  dPath &lt;- asPath(getOption(\"reproducible.destinationPath\", dataPath(sim)), 1)\n  message(currentModule(sim), \": using dataPath '\", dPath, \"'.\")\n  \n  # ! ----- EDIT BELOW ----- ! #\n  \n  # ! ----- STOP EDITING ----- ! #\n  return(invisible(sim))\n}\n\n\nAnd the script with the accessory functions:\n\n\nCode\n## Accessory functions to speciesTempLM module\n\n#' Accessory function to speciesTempLM module that calculates a\n#'  linear regression between species abundances and temperature\n#'\n#' @param Data a data.frame or data.table that contains an \\code{abund}\n#'   column and a \\code{temp} column with abundance and temperature values \n#'   in each location, respectively.\n#' @return a linear model (\\code{lm}) object fitted with the formula:\n#'  \\code{abund ~ temp}\n\nlinearModel &lt;- function(Data) {\n    lm1 &lt;- lm(abund ~ temp, data = Data)\n    return(lm1)\n}\n\n\n\n\n\n1.2.5 Simulation\n\n1.2.5.1 Simulation setup in a “global” script\nWe can now go back to our Part1_DummyModel.R script and set the simulation up.\nThe function simInit needs a few arguments listing simulation folder directories, parameters, simulation times, modules and, optionally, input objects supplied by the user. simInit will prepare a simulation object that can later be run by the spades function:\n\nThe first list, modules, contains modules we want to activate.\ntimes is a named list containing the start and end times of the simulation and what time units we’re working with (with “start” and “end” being the list names. It thus defines the length of the simulation. It is important that the start and ending times are defined in decimals, because SpaDES allows decomposing time units into smaller fractions.\nparameters is a named list of named lists, containing parameters values passed to each module. Note that because the module metadata will (or should) contain default parameter values, here we pass only parameters which we want to change with respect to their defaults. For instance, .plotInterval is used and defined in the speciesAbundance and temperature modules, but not passed to the simInit function because we want to use the default value. As a developer providing a reproducible example, we may also chose to list important and useful parameters, even if the value is the same as the default. Here we chose to list .plotInitialTime (a parameter used and defined in the speciesAbundance and temperature modules), but provide the default value (we experimenting with it by changing its value in the Part1_DummyModel.R).\npaths contains the folder directory paths that we set earlier.\n\n\n\nCode\n## list the modules to use\nsimModules &lt;- list(\"speciesAbundance\", \"temperature\", \"speciesTempLM\")\n\n## Set simulation and module parameters\nsimTimes &lt;- list(start = 1, end = 10, timeunit = \"year\")\nsimParams &lt;- list(speciesAbundance = list(simulationTimeStep = 1,\n    .plotInitialTime = 1), temperature = list(simulationTimeStep = 1,\n    .plotInitialTime = 1), speciesTempLM = list(statsTimestep = 5))\n\n## make a list of directory paths\nsimPaths &lt;- getPaths()\n\n## Simulation setup\nmySim &lt;- simInit(times = simTimes, params = simParams, modules = simModules,\n    paths = simPaths)\n\n\nFinally, we highlight that simInit also executes all .inputObjects functions, and schedules the init events, but does not execute them:\n\n\nCode\nevents(mySim)\n\n\n\n\n1.2.5.2 Checking the simulation setup\nBefore starting the simulations we should check if the modules were linked correctly.\nModule diagram\nmoduleDiagram (Figure 1.2 ) is a useful function that shows module inter-dependencies as a network diagram. The direction of the arrows indicates an output to input flow. You can see that speciesAbundance and temperature inputs (specifically our `r` raster) are supplied by an external source (INPUT) - the user or .inputObjects. Whereas the inputs to the speciesTempLM module are outputs of the speciesAbundance and temperature modules.\n\n\nCode\nmoduleDiagram(mySim)\n\n\n\n\n\n\n\n\nFigure 1.2: Diagram of module connections.\n\n\n\n\n\nObject diagram\nobjectDiagram (Figure 1.3) provides another way of checking module linkages. It explicitly shows module inter-dependencies by depicting the objects that establish links between modules.\n\n\nCode\nobjectDiagram(mySim)\n\n\n\n\n\n\n\n\n\n\nFigure 1.3: Module diagram showing module inter-dependencies with object names.\n\n\n\n\n\n\n\n1.2.5.3 Running SpaDES\nWe run the simulation using the spades function, which takes the output of the simInit, executes the already scheduled init events, which schedule the remainder of the events. We passed debug = TRUE so that spades prints the events as they are being executed. In case something fails, this helps diagnosing where the issue occurred.\n\n\nCode\n## run simulation\ndev()  # on Windows and Mac, this opens external device if using Rstudio, it is faster\nclearPlot()\nmySim2 &lt;- spades(mySim, debug = TRUE)\n\n\n\n\n\n\n\nSimulation plots: Final plot of the simulation\n\n\n\n\nWe suggest experimenting with changing parameter values and trying to create and add other modules to further explore all the SpaDES flexibility. The more complex the project gets, the more advantageous it is to use SpaDES to turn modules on or off, swapping modules to run, e.g., different statistical analyses, or to include different data.\n\n\n\n\n1.2.6 Additional notes\nSpaDES is an extremely powerful package, whose potential goes well beyond what has been discussed in this dummy example. If you want to explore it further, we recommend following Chapter 2 for a more realistic (but still simple) SpaDES application.\nAlso, do go to the SpaDES webpage to find further information about the platform, as well as upcoming workshops and publications and to the Predictive Ecology Github repository to see all the SpaDES modules and SpaDES-related packages that we maintain at the Predictive Ecology Lab.\n\n\nHappy SpaDESing!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducing `SpaDES` with a dummy ecological model</span>"
    ]
  },
  {
    "objectID": "Part2_SDMs.html#the-example-projecting-species-distribution-shifts-under-climate-change",
    "href": "Part2_SDMs.html#the-example-projecting-species-distribution-shifts-under-climate-change",
    "title": "2  A more realistic example of SpaDES",
    "section": "2.1 The example: projecting species distribution shifts under climate change",
    "text": "2.1 The example: projecting species distribution shifts under climate change\nSpecies distribution models (SDMs) have been widely used in ecology to predict how species presences and absences across a landscape may change under changing environmental conditions. As a result, there are several R packages that have been built with this in mind [e.g. `dismo` @dismo; `biomod2` @biomod2] and many ecologists do these analyses exclusively in R.\nOften, these analyses are run only once for a given set of species, baseline and projected environmental conditions, and researchers will have a few R scripts (or maybe just one longer script) that load the data into R, do any necessary pre-processing steps, fit the models and run species distribution projections. The usefulness of SpaDES comes when we want an automated and standardized workflow that can be easily updated with new data and adapted with new algorithms. SpaDES provides a common standard and a modular approach to modelling that facilitates expanding, debugging and sharing code, but also various tools that bring many well-known best practices from computer- and data-science workflows (including reproducible, modular workflows, and caching), to the realm of ecological modelling, so that they can be used by non-computer-scientists with minimal learning. In an SDM project this means that updating data and algorithms, and automating iterative forecasting become easier and less prone to errors. When SpaDES modules are open and shared, this also expands a potential pool of users who can themselves help improve the code.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A more realistic example of `SpaDES`</span>"
    ]
  },
  {
    "objectID": "Part2_SDMs.html#module-creation-and-coding",
    "href": "Part2_SDMs.html#module-creation-and-coding",
    "title": "2  A more realistic example of SpaDES",
    "section": "2.2 Module creation and coding",
    "text": "2.2 Module creation and coding\nWith the above in mind, in this example we created three modules that source and pre-process data (‘data modules’) and a module that fits an SDM and iteratively forecasts species distributions (we call it a ‘simulation module’, although the simulation only involves predicting from a statistical model). The idea is that we could, for instance, provide different data sources to one of the data modules and only update the parts of the simulation that are affected by this change (i.e. presumably the other data module steps with not be affected). Or, we could develop a second simulation module using a different SDM approach and swap the two modules to inspect which provides better predictions.\nOur data modules are speciesAbundanceData and climateData. The simulation module is projectSpeciesDist. We start by creating an .R script to set up and control the simulation. In this example this script is called Part2_SDMs.R.\nThe script begins with a few lines of code that ensure a few packages are installed and loaded (see Reproducible package installation). It then defines the necessary folder directories for the simulation and creates the modules in the modules/ folder.\n\n\nCode\noptions(repos = c(\"https://predictiveecology.r-universe.dev/\", \n                  CRAN = \"https://cloud.r-project.org\"))\n\nif (getRversion() &lt; \"4.2.1\") {\n  warning(paste(\"dismo::maxent may create a fatal error\",\n                \"when using R version &lt; v4.2.1 and from RStudio.\\n\", \n                \"Please upgrade R, or run this script outside of RStudio.\\n\",\n                \"See https://github.com/rspatial/dismo/issues/13\"))\n}\n\n## decide where you're working\nmainPath &lt;- file.path(\"~/SpaDES4Dummies_Part2\")\npkgPath &lt;- file.path(mainPath, \"packages\", version$platform,\n                     paste0(version$major, \".\", strsplit(version$minor, \"[.]\")[[1]][1]))\ndir.create(pkgPath, recursive = TRUE)\n.libPaths(pkgPath, include.site = FALSE) ## install packages in project library (proj-lib)\n\nif (!\"remotes\" %in% installed.packages(lib.loc = pkgPath))\n  install.packages(\"remotes\")\n\nif (!\"Require\" %in% installed.packages(lib.loc = pkgPath) ||\n    packageVersion(\"Require\", lib.loc = pkgPath) &lt; \"0.3.1.9015\") {\n  remotes::install_github(\"PredictiveEcology/Require@2788b023ad191c29346ef8c64df71b937be307e2\",\n                          upgrade = FALSE)\n}\n\n## Notes: \n## 1) if you are working from RStudio and have an older version of base packages like `Rcpp`, `rlang` \n## (and others) installed, you may  need to run the following lines (and code above) directly from R\n## in order to update these base packages\n## 2) Please ensure the appropriate Rtools version is installed (see)\n\n## there seems to be a problem with `ragg` and a forced install solves it\nif (!\"ragg\" %in% installed.packages(lib.loc = pkgPath)) {\n  install.packages(\"ragg\")\n}\n\nRequire::Require(c(\"PredictiveEcology/SpaDES.project@transition (HEAD)\", \n                   \"PredictiveEcology/SpaDES.core@master (HEAD)\",\n                   ## these will be needed later on:\n                   \"ggpubr\",\n                   \"geodata\",\n                   \"SpaDES.tools\",\n                   \"PredictiveEcology/SpaDES.experiment@75d917b70b892802fed0bbdb2a5e9f3c6772f0ba\"),\n                 require = FALSE,  ## don't load packages yet \n                 upgrade = FALSE, standAlone = TRUE)\n\nRequire::Require(\"SpaDES.core\", install = FALSE)  ## load only\nsetPaths(cachePath = file.path(mainPath, \"cache\"),\n         inputPath = file.path(mainPath, \"inputs\"),\n         modulePath = file.path(mainPath, \"modules\"),\n         outputPath = file.path(mainPath, \"outputs\"))\n\nsimPaths &lt;- getPaths() ## check that this is what you wanted\n\n## Let's create a self-contained module that will simulate the species' abundance for any given period of time and frequency.\nif (!dir.exists(file.path(simPaths$modulePath, \"speciesAbundanceData\"))) {\n  newModule(name = \"speciesAbundanceData\", path = simPaths$modulePath)\n}\n\nif (!dir.exists(file.path(simPaths$modulePath, \"climateData\"))) {\n  newModule(name = \"climateData\", path = simPaths$modulePath)\n}\n\nif (!dir.exists(file.path(simPaths$modulePath, \"projectSpeciesDist\"))) {\n  newModule(name = \"projectSpeciesDist\", path = simPaths$modulePath)\n}\n\n\nNotice how we protect the newModule call with an if statement that first detects whether the module directory exists already. This is necessary to prevent overwriting existing modules should this script be run a second time in the same location (see Protect yourself and others from common mistakes/problems).\nsetPaths will create the project folder directories in case they do not exist (no overwriting occurs in case they do).\nFinally, note that we do not load any R packages yet, as we will later use Require to make sure all module dependencies are installed before running the simulation (see Reproducible package installation). Because Require may attempt to install missing packages and because installing packages should be done in a clean R session, we will only load any packages after all the installation steps are complete.\n\n2.2.1 Data modules\nThe next two sections show our two data modules .R scripts. We assume you are already familiar with the different parts of a module .R script; if not, see Chapter 1. We do not discuss the module .Rmd files, which should document each module in detail (see [Module documentation – module .Rmd]).\n\n2.2.1.1 speciesAbundanceData module:\nThis module downloads freely available spatial layers of Picea glauca percent cover (% cover) across Canada and pre-processes them to match a user-supplied study area raster. We use the new terra package throughout this example, since the raster package will soon be discontinued.\nThe prepInputs function downloads the % cover layer from the Canadian National Forest Inventory data server using the URL supplied by sppAbundURL and processes it to match the study area raster (studyAreaRas) supplied by the user. The module then outputs Picea glauca % cover as a raster (sppAbundanceRas) and as a data.table (sppAbundanceDT). The data.table contains added information about the year of the simulation during which the data should be used (here, only the first year when SDM fitting happens).\nWe export species % cover in two formats (a raster and a table) for demonstrational purposes, but also because we could envision that this model (i.e. group of modules) could save the species distribution projections for several points in time in a more compact format of a data.table – large raster layers can consume a considerable amount of disk space (see Coding for the future).\n\n\nCode\n## Everything in this file and any files in the R directory are sourced during `simInit()`;\n## all functions and objects are put into the `simList`.\n## To use objects, use `sim$xxx` (they are globally available to all modules).\n## Functions can be used inside any function that was sourced in this module;\n## they are namespaced to the module, just like functions in R packages.\n## If exact location is required, functions will be: `sim$.mods$&lt;moduleName&gt;$FunctionName`.\ndefineModule(sim, list(\n  name = \"speciesAbundanceData\",\n  description = paste(\"Data module to prepare tree species cover data for species distribution modelling.\", \n                      \"Defaults to using Canadian National Forest Inventory data.\"),\n  keywords = c(\"minimal SpaDES example\", \"species distribution model\"),\n  authors = structure(list(list(given = c(\"Ceres\"), family = \"Barros\", role = c(\"aut\", \"cre\"), \n                                email = \"ceres.barros@ubc.ca\", comment = NULL)), class = \"person\"),\n  childModules = character(0),\n  version = list(speciesAbundanceData = \"1.0.0\"),\n  timeframe = as.POSIXlt(c(NA, NA)),\n  timeunit = \"year\",\n  citation = list(\"citation.bib\"),\n  documentation = list(\"README.md\", \"speciesAbundanceData.Rmd\"), ## same file\n  reqdPkgs = list(\"SpaDES.core (&gt;=2.0.2)\",\n                  \"httr\", \"terra\", \"ggplot2\", \"rasterVis\"),\n  parameters = bindrows(\n    #defineParameter(\"paramName\", \"paramClass\", value, min, max, \"parameter description\"),\n    defineParameter(\"sppAbundURL\", \"character\", \n                    paste0(\"https://ftp.maps.canada.ca/pub/nrcan_rncan/Forests_Foret/\",\n                           \"canada-forests-attributes_attributs-forests-canada/\",\n                           \"2001-attributes_attributs-2001/\",\n                           \"NFI_MODIS250m_2001_kNN_Species_Pice_Gla_v1.tif\"), NA, NA,\n                    paste(\"URL where the first SpatRaster of species abundance resides.\",\n                          \"This will be the abundance data used to fit the species ditribution model.\",\n                          \"Defaults to *Picea glauca* percent cover across Canada, in 2001\", \n                          \"(from Canadian National Forest Inventory forest attributes)\")),\n    defineParameter(\".plots\", \"character\", \"screen\", NA, NA,\n                    \"Used by Plots function, which can be optionally used here\"),\n    defineParameter(\".plotInitialTime\", \"numeric\", start(sim), NA, NA,\n                    \"Describes the simulation time at which the first plot event should occur.\"),\n    defineParameter(\".plotInterval\", \"numeric\", NA, NA, NA,\n                    \"Describes the simulation time interval between plot events.\"),\n    defineParameter(\".saveInitialTime\", \"numeric\", NA, NA, NA,\n                    \"Describes the simulation time at which the first save event should occur.\"),\n    defineParameter(\".saveInterval\", \"numeric\", NA, NA, NA,\n                    \"This describes the simulation time interval between save events.\"),\n    defineParameter(\".studyAreaName\", \"character\", NA, NA, NA,\n                    \"Human-readable name for the study area used. If NA, a hash of studyArea will be used.\"),\n    ## .seed is optional: `list('init' = 123)` will `set.seed(123)` for the `init` event only.\n    defineParameter(\".seed\", \"list\", list(), NA, NA,\n                    \"Named list of seeds to use for each event (names).\"),\n    defineParameter(\".useCache\", \"logical\", FALSE, NA, NA,\n                    \"Should caching of events or module be used?\")\n  ),\n  inputObjects = bindrows(\n    #expectsInput(\"objectName\", \"objectClass\", \"input object description\", sourceURL, ...),\n    expectsInput(\"studyAreaRas\", objectClass = \"SpatRaster\", \n                 desc = \"A binary raster of the study area\")\n  ),\n  outputObjects = bindrows(\n    #createsOutput(\"objectName\", \"objectClass\", \"output object description\", ...),\n    createsOutput(\"sppAbundanceDT\", \"data.table\", \n                  desc = paste(\"Species abundance data from `sppAbundanceRas`, with columns 'cell',\",\n                               \"'x', 'y', 'sppAbund' and 'year' (an integer matching the number in\",\n                               \"names(`sppAbundanceRas`).\" )),\n    createsOutput(\"sppAbundanceRas\", \"SpatRaster\", \n                  desc = paste(\"A species abundance layer used to fit a species distribution model\",\n                               \"at the start of the simulation. Layers named as:\",\n                               \"paste('year', start(sim):end(sim), sep = '_')). Data obtained from\",\n                               \"P(sim)$sppAbundURL\"))\n  )\n))\n\n## event types\n#   - type `init` is required for initialization\n\ndoEvent.speciesAbundanceData = function(sim, eventTime, eventType, debug = FALSE) {\n  switch(\n    eventType,\n    init = {\n      ## do stuff for this event\n      sim &lt;- abundanceInit(sim)\n      \n      ## schedule future event(s)\n      sim &lt;- scheduleEvent(sim, eventTime = P(sim)$.plotInitialTime, \n                           moduleName = \"speciesAbundanceData\", eventType = \"abundPlot\",\n                           eventPriority = .normal())\n    },\n    abundPlot = {\n      ## do stuff for this event\n      sim &lt;- abundancePlot(sim)\n    },\n    warning(paste(\"Undefined event type: '\", current(sim)[1, \"eventType\", with = FALSE],\n                  \"' in module '\", current(sim)[1, \"moduleName\", with = FALSE], \"'\", sep = \"\"))\n  )\n  return(invisible(sim))\n}\n\n## event functions\n#   - keep event functions short and clean, modularize by calling subroutines from section below.\n\n## Initialisation Event function\nabundanceInit &lt;- function(sim) {\n  ## download data - prepInputs does all the heavy-lifting of dowloading and pre-processing the layer and caches.\n  ## there seems to be an issue masking this particular raster with `terra` and `GDAL`, so we'll not use them here.\n  opts &lt;- options(\"reproducible.useTerra\" = FALSE,\n                  \"reproducible.useGDAL\" = FALSE)   \n  on.exit(options(opts), add = TRUE)\n\n  httr::with_config(config = httr::config(ssl_verifypeer = 0L), {\n    sppAbundanceRas &lt;- prepInputs(targetFile = \"NFI_MODIS250m_2001_kNN_Species_Pice_Gla_v1.tif\",\n                                  url = P(sim)$sppAbundURL,\n                                  # fun = \"terra::rast\",\n                                  # projectTo = sim$studyAreaRas,\n                                  # cropTo = sim$studyAreaRas,\n                                  # maskTo = sim$studyAreaRas,\n                                  rasterToMatch = raster::raster(sim$studyAreaRas),\n                                  maskWithRTM = TRUE,\n                                  overwrite = TRUE,\n                                  cacheRepo = cachePath(sim))\n  })\n  \n  options(opts)\n  \n  if (is(sppAbundanceRas, \"RasterLayer\")) {\n    sppAbundanceRas &lt;- terra::rast(sppAbundanceRas)\n  }\n  \n  names(sppAbundanceRas) &lt;- paste(\"year\", time(sim), sep = \"_\")\n  sppAbundanceDT &lt;- as.data.table(as.data.frame(sppAbundanceRas, xy = TRUE, cells = TRUE))\n  sppAbundanceDT[, year := as.integer(sub(\"year_\", \"\", names(sppAbundanceRas)))]\n  setnames(sppAbundanceDT, \"year_1\", \"sppAbund\")\n  \n  ## export to sim\n  sim$sppAbundanceRas &lt;- sppAbundanceRas\n  sim$sppAbundanceDT &lt;- sppAbundanceDT\n  \n  return(invisible(sim))\n}\n\n## Plotting event function \nabundancePlot &lt;- function(sim) {\n  ## plot species abundance\n  Plots(sim$sppAbundanceRas, fn = plotSpatRaster, types = P(sim)$.plots,\n        usePlot = TRUE, filename = file.path(outputPath(sim), \"figures\", \"speciesAbundance\"), \n        plotTitle = \"Species abundance data\", xlab = \"Longitude\", ylab = \"Latitude\")\n  \n  return(invisible(sim))\n}\n\n\n.inputObjects &lt;- function(sim) {\n  #cacheTags &lt;- c(currentModule(sim), \"function:.inputObjects\") ## uncomment this if Cache is being used\n  dPath &lt;- asPath(getOption(\"reproducible.destinationPath\", dataPath(sim)), 1)\n  message(currentModule(sim), \": using dataPath '\", dPath, \"'.\")\n  \n  # ! ----- EDIT BELOW ----- ! #\n  \n  if (!suppliedElsewhere(sim$studyAreaRas)) {\n    ## code check: did the user supply a study area?\n    stop(\"Please supply a 'studyAreaRas' SpatRaster\")\n  }\n  \n  # ! ----- STOP EDITING ----- ! #\n  return(invisible(sim))\n}\n\n\n\n\n2.2.1.2 climateData module:\nThis module downloads and processes freely available spatial layers of four bioclimatic variables used to fit the SDM of Picea glauca in the study area.\nThe module uses a different way to download data. It relies on two input data.tables that contain the URLs for each climate covariate, one for baseline conditions, the other for projected climate conditions, both containing information about when each layer should be used during the simulation (the “year”column).\nWe have only supplied one set of data sources for default baseline climate conditions (baselineClimateURLs) and for climate projections (projClimateURLs), all of which are downloaded from WorldClim at 2.5 minutes resolution. The baseline climate data correspond to the 1970-2000 period @FickHijmans2017, which aligns well with the species % cover data year (2001). The climate projections were obtained for 2021-2040, 2041-2060, 2061-2080 and 2081-2100, from CMIP6 downscaled future projections using the CanESM5 model [@SwartEtAl2019] under the SSP 585 climate scenario.\nWe encourage providing different (or additional) URLs referring to projections for other climate periods, other climate models and other climate scenarios (see WorldClim for a list of climate projections).\nIf providing other URLs to obtain different climate data, pay special attention to the “year” column of projClimateURLs – the URLs need to correspond to the simulation year during which they will be used (not necessarily the actual climate year, unless the simulation years follow the same numbering).\nLike in the speciesAbundanceData module, the prepInputs function processes the climate layers to match the study area raster (studyAreaRas) and compiles all climate data in the climateDT object and as raster layer objects (baselineClimateRas and projClimateRas) – the module’s outputs.\n\n\nCode\n## Everything in this file and any files in the R directory are sourced during `simInit()`;\n## all functions and objects are put into the `simList`.\n## To use objects, use `sim$xxx` (they are globally available to all modules).\n## Functions can be used inside any function that was sourced in this module;\n## they are namespaced to the module, just like functions in R packages.\n## If exact location is required, functions will be: `sim$.mods$&lt;moduleName&gt;$FunctionName`.\ndefineModule(sim, list(\n  name = \"climateData\",\n  description = paste(\"Data module to prepare climate data for species distribution modelling.\", \n                      \"Defaults to using bioclimatic variables from Worldclim.\"),\n  keywords = c(\"minimal SpaDES example\", \"species distribution model\"),\n  authors = structure(list(list(given = c(\"Ceres\"), family = \"Barros\", role = c(\"aut\", \"cre\"), email = \"ceres.barros@ubc.ca\", comment = NULL)), class = \"person\"),\n  childModules = character(0),\n  version = list(climateData = \"1.0.0\"),\n  timeframe = as.POSIXlt(c(NA, NA)),\n  timeunit = \"year\",\n  citation = list(\"citation.bib\"),\n  documentation = list(\"README.md\", \"climateData.Rmd\"), ## same file\n  reqdPkgs = list(\"SpaDES.core (&gt;=2.0.2)\",\n                  \"ggplot2\", \"rasterVis\", \"terra\", \"data.table\"),\n  parameters = bindrows(\n    #defineParameter(\"paramName\", \"paramClass\", value, min, max, \"parameter description\"),\n    defineParameter(\".plots\", \"character\", \"screen\", NA, NA,\n                    \"Used by Plots function, which can be optionally used here\"),\n    defineParameter(\".plotInitialTime\", \"numeric\", start(sim), NA, NA,\n                    \"Describes the simulation time at which the first plot event should occur.\"),\n    defineParameter(\".plotInterval\", \"numeric\", NA, NA, NA,\n                    \"Describes the simulation time interval between plot events.\"),\n    defineParameter(\".saveInitialTime\", \"numeric\", NA, NA, NA,\n                    \"Describes the simulation time at which the first save event should occur.\"),\n    defineParameter(\".saveInterval\", \"numeric\", NA, NA, NA,\n                    \"This describes the simulation time interval between save events.\"),\n    defineParameter(\".studyAreaName\", \"character\", NA, NA, NA,\n                    \"Human-readable name for the study area used. If NA, a hash of studyArea will be used.\"),\n    ## .seed is optional: `list('init' = 123)` will `set.seed(123)` for the `init` event only.\n    defineParameter(\".seed\", \"list\", list(), NA, NA,\n                    \"Named list of seeds to use for each event (names).\"),\n    defineParameter(\".useCache\", \"logical\", FALSE, NA, NA,\n                    \"Should caching of events or module be used?\")\n  ),\n  inputObjects = bindrows(\n    #expectsInput(\"objectName\", \"objectClass\", \"input object description\", sourceURL, ...),\n    expectsInput(\"baselineClimateURLs\", \"data.table\", \n                 desc = paste(\"A table with columns 'vars', 'URL', 'targetFile' and 'year', containing\",\n                              \"variable names, URLs and raster file names of each climate covariate\",\n                              \"used in the species distribution models. Year is the first year of the\", \n                              \"simulation (not the reference climate period). Defaults to Worldclim's\",\n                              \"'bio1', 'bio4', 'bio12' and 'bio15' bioclimatic variables for the 1970-2000\",\n                              \"climate period, at 2.5 minutes.\")),\n    expectsInput(\"projClimateURLs\", \"data.table\", \n                 desc = paste(\"Same as `baselineClimateURLs` but refering to projected climate layers.\",\n                              \"Variable names in 'vars' need to the same as in `baselineClimateURLs`\",\n                              \"and P(sim)$projClimateURLs. Years should correspond to simulation years.\",\n                              \"Defaults to 2081-2100 projections using the CanESM5 climate model and the\",\n                              \"SSP 585 climate scenario, at 2.5 minutes, obtained from Worldclim.\")),\n    expectsInput(\"studyAreaRas\", objectClass = \"SpatRaster\", \n                 desc = \"A binary raster of the study area\")\n  ),\n  outputObjects = bindrows(\n    #createsOutput(\"objectName\", \"objectClass\", \"output object description\", ...),\n    createsOutput(\"climateDT\", \"data.table\", \n                  desc = paste(\"A data.table with as many columns as the climate covariates\", \n                               \"used in the species distribution model and 'year' column describing\",\n                               \"the simulation year to which the data corresponds.\")),\n    createsOutput(\"baselineClimateRas\", \"SpatRaster\", \n                  desc = paste(\"Baseline climate layers obtained from `baselineClimateURLs`\")),\n    createsOutput(\"projClimateRas\", \"SpatRaster\", \n                  desc = paste(\"Baseline climate layers obtained from `projClimateURLs`\"))\n  )\n))\n\n## event types\n#   - type `init` is required for initialization\n\ndoEvent.climateData = function(sim, eventTime, eventType, debug = FALSE) {\n  switch(\n    eventType,\n    init = {\n      ## do stuff for this event\n      sim &lt;- climateInit(sim)\n      \n      ## schedule future event(s)\n      sim &lt;- scheduleEvent(sim, eventTime = P(sim)$.plotInitialTime, \n                           moduleName = \"climateData\", eventType = \"climPlot\",\n                           eventPriority = .normal())\n    },\n    climPlot = {\n      ## do stuff for this event\n      sim &lt;- climatePlot(sim)\n    },\n    warning(paste(\"Undefined event type: '\", current(sim)[1, \"eventType\", with = FALSE],\n                  \"' in module '\", current(sim)[1, \"moduleName\", with = FALSE], \"'\", sep = \"\"))\n  )\n  return(invisible(sim))\n}\n\n## event functions\n#   - keep event functions short and clean, modularize by calling subroutines from section below.\n\n## Initialisation Event function\nclimateInit &lt;- function(sim) {\n  ## GET BASELINE DATA\n  ## make a vector of archive (zip) file names if the url points to one.\n  archiveFiles &lt;- sapply(sim$baselineClimateURLs$URL, function(URL) {\n    if (grepl(\"\\\\.zip$\", basename(URL))) {\n      basename(URL)\n    } else {\n      NULL\n    }\n  }, USE.NAMES = FALSE)\n  \n  ## check that baseline climate data only has one year value\n  if (length(unique(sim$baselineClimateURLs$year)) != 1) {\n    stop(paste(\"'baselineClimateURLs' should all have the same 'year' value,\",\n               \"corresponding to the first year of the simulation\"))\n  }\n  ## download data - prepInputs does all the heavy-lifting of dowloading and pre-processing the layer and caches.\n  baselineClimateRas &lt;- Cache(Map, \n                              f = prepInputs,\n                              url = sim$baselineClimateURLs$URL,\n                              targetFile = sim$baselineClimateURLs$targetFile,\n                              archive = archiveFiles,\n                              MoreArgs = list(\n                                fun = \"terra::rast\",\n                                overwrite = TRUE,\n                                projectTo = sim$studyAreaRas,\n                                cropTo = sim$studyAreaRas,\n                                maskTo = sim$studyAreaRas,\n                                rasterToMatch = sim$studyAreaRas,\n                                cacheRepo = cachePath(sim)),\n                              cacheRepo = cachePath(sim))\n  \n  names(baselineClimateRas) &lt;- paste0(sim$baselineClimateURLs$vars, \"_year\", sim$baselineClimateURLs$year)\n  \n  ## make a stack\n  baselineClimateRas &lt;- rast(baselineClimateRas)\n  \n  ## make a data.table \n  baselineClimateData &lt;- as.data.table(as.data.frame(baselineClimateRas, xy = TRUE, cells = TRUE))\n  setnames(baselineClimateData, sub(\"_year.*\", \"\", names(baselineClimateData))) ## don't need year in names here \n  baselineClimateData[, year := unique(sim$baselineClimateURLs$year)]\n  \n  ## GET PROJECTED DATA\n  ## make a vector of archive (zip) file names if the url points to one.\n  archiveFiles &lt;- lapply(sim$projClimateURLs$URL, function(URL) {\n    if (grepl(\"\\\\.zip$\", basename(URL))) {\n      basename(URL)\n    } else {\n      NULL\n    }\n  })\n  \n  ## download data - prepInputs does all the heavy-lifting of dowloading and pre-processing the layer and caches.\n  ## workaround Mar 30th 2022 cache issue with terra.\n  projClimateRas &lt;- Cache(Map, \n                          f = prepInputs,\n                          url = sim$projClimateURLs$URL,\n                          targetFile = sim$projClimateURLs$targetFile,\n                          archive = archiveFiles,\n                          MoreArgs = list(\n                            overwrite = TRUE,\n                            fun = \"raster::stack\",\n                            projectTo = sim$studyAreaRas,\n                            cropTo = sim$studyAreaRas,\n                            maskTo = sim$studyAreaRas,\n                            rasterToMatch = sim$studyAreaRas,\n                            cacheRepo = cachePath(sim)),\n                          cacheRepo = cachePath(sim))\n  if (any(sapply(projClimateRas, function(x) is(x, \"RasterLayer\") | is(x, \"RasterStack\")))){\n    projClimateRas &lt;- lapply(projClimateRas, terra::rast)\n  }\n  \n  ## these rasters are different. The tif file contains all the variables in different layers\n  ## so, for each variable, we need to keep only the layer of interest\n  projClimateRas &lt;- mapply(function(stk, var) {\n    lyr &lt;- which(sub(\".*_\", \"BIO\", names(projClimateRas[[1]])) == var)\n    return(stk[[lyr]])\n  }, stk = projClimateRas, var = sim$projClimateURLs$vars)\n  names(projClimateRas) &lt;- paste0(sim$projClimateURLs$vars, \"_year\", sim$projClimateURLs$year)\n  \n  ## make a stack\n  projClimateRas &lt;- rast(projClimateRas)\n  \n  ## make a data.table \n  projClimateData &lt;- as.data.table(as.data.frame(projClimateRas, xy = TRUE, cells = TRUE))\n  \n  ## melt so that year is in a column\n  projClimateDataMolten &lt;- lapply(unique(sim$projClimateURLs$vars), function(var, projClimateData) {\n    cols &lt;- grep(paste0(var, \"_year\"), names(projClimateData), value = TRUE)\n    idCols &lt;- names(projClimateData)[!grepl(\"_year\", names(projClimateData))]\n    \n    moltenDT &lt;-  melt(projClimateData, id.vars = idCols, measure.vars = cols, \n                      variable.name = \"year\", value.name = var)\n    moltenDT[, year := sub(paste0(var, \"_year\"), \"\", year)]\n    moltenDT[, year := as.integer(year)]\n    return(moltenDT)\n  }, projClimateData = projClimateData)\n  \n  idCols &lt;- c(names(projClimateData)[!grepl(\"_year\", names(projClimateData))], \"year\")\n  ## set keys for merge\n  projClimateDataMolten &lt;- lapply(projClimateDataMolten, function(DT, cols) {\n    setkeyv(DT, cols = cols)\n    return(DT)\n  }, cols = idCols)\n  \n  projClimateData &lt;- Reduce(merge, projClimateDataMolten)\n  \n  ## bind the two data.tables\n  if (!identical(sort(names(baselineClimateData)), sort(names(projClimateData)))) {\n    stop(\"Variable names in `projClimateURLs` differ from those in `baselineClimateURLs`\")\n  }\n  \n  ## check\n  if (!compareGeom(baselineClimateRas, projClimateRas, res = TRUE, stopOnError = FALSE)) {\n    stop(\"`baselineClimateRas` and `projClimateRas` do not have the same raster properties\")\n  }\n  \n  ## export to sim\n  sim$baselineClimateRas &lt;- baselineClimateRas\n  sim$projClimateRas &lt;- projClimateRas\n  sim$climateDT &lt;- rbindlist(list(baselineClimateData, projClimateData), use.names = TRUE)\n  \n  return(invisible(sim))\n}\n\n## Plotting event function \nclimatePlot &lt;- function(sim) {\n  ## plot climate rasters \n  allRasters &lt;- rast(list(sim$baselineClimateRas, sim$projClimateRas))\n  lapply(sim$baselineClimateURLs$vars, function(var, allRasters) {\n    lrs &lt;- grep(paste0(var, \"_\"), names(allRasters))\n    file_name &lt;- paste0(\"climateRas_\", var)\n    Plots(allRasters[[lrs]],\n          fn = plotSpatRasterStk, types = P(sim)$.plots,\n          usePlot = FALSE,\n          filename = file.path(outputPath(sim), \"figures\", file_name),\n          xlab = \"Longitude\", ylab = \"Latitude\")\n  }, allRasters = allRasters)\n  \n  return(invisible(sim))\n}\n\n\n.inputObjects &lt;- function(sim) {\n  #cacheTags &lt;- c(currentModule(sim), \"function:.inputObjects\") ## uncomment this if Cache is being used\n  dPath &lt;- asPath(getOption(\"reproducible.destinationPath\", dataPath(sim)), 1)\n  message(currentModule(sim), \": using dataPath '\", dPath, \"'.\")\n  \n  # ! ----- EDIT BELOW ----- ! #\n  \n  if (!suppliedElsewhere(sim$studyAreaRas)) {\n    ## code check: did the user supply a study area?\n    stop(\"Please supply a 'studyAreaRas' SpatRaster\")\n  }\n  \n  if (!is(sim$studyAreaRas, \"SpatRaster\")) {\n    sim$studyAreaRas &lt;- rast(sim$studyAreaRas)\n  }\n  \n  if (!suppliedElsewhere(sim$baselineClimateURLs)) {\n    sim$baselineClimateURLs &lt;- data.table(\n      vars = c(\"BIO1\", \"BIO4\", \"BIO12\", \"BIO15\"),\n      URL = c(\"https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_2.5m_bio.zip\",\n              \"https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_2.5m_bio.zip\",\n              \"https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_2.5m_bio.zip\",\n              \"https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc2.1_2.5m_bio.zip\"),\n      targetFile = c(\"wc2.1_2.5m_bio_1.tif\", \"wc2.1_2.5m_bio_4.tif\", \n                     \"wc2.1_2.5m_bio_12.tif\", \"wc2.1_2.5m_bio_15.tif\"),\n      year = rep(1L, 4)\n    )\n  }\n  \n  if (!suppliedElsewhere(sim$projClimateURLs)) {\n    sim$projClimateURLs &lt;- data.table(\n      vars = rep(c(\"BIO1\", \"BIO4\", \"BIO12\", \"BIO15\"), times = 4),\n      URL = rep(c(\"https://geodata.ucdavis.edu/cmip6/2.5m/CanESM5/ssp585/wc2.1_2.5m_bioc_CanESM5_ssp585_2021-2040.tif\",\n                  \"https://geodata.ucdavis.edu/cmip6/2.5m/CanESM5/ssp585/wc2.1_2.5m_bioc_CanESM5_ssp585_2041-2060.tif\",\n                  \"https://geodata.ucdavis.edu/cmip6/2.5m/CanESM5/ssp585/wc2.1_2.5m_bioc_CanESM5_ssp585_2061-2080.tif\",\n                  \"https://geodata.ucdavis.edu/cmip6/2.5m/CanESM5/ssp585/wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif\"),\n                each = 4),\n      targetFile = rep(c(\"wc2.1_2.5m_bioc_CanESM5_ssp585_2021-2040.tif\",\n                         \"wc2.1_2.5m_bioc_CanESM5_ssp585_2041-2060.tif\",\n                         \"wc2.1_2.5m_bioc_CanESM5_ssp585_2061-2080.tif\",\n                         \"wc2.1_2.5m_bioc_CanESM5_ssp585_2081-2100.tif\"),\n                       each = 4),\n      year = rep(2L:5L, each = 4)\n    )\n  } \n  \n  # ! ----- STOP EDITING ----- ! #\n  return(invisible(sim))\n}\n\n\nWe draw your attention to a few particular aspects of the data modules:\n\nHow we took care to define the data classes of parameters, expected inputs and module outputs in their respective metadata sections;\nHow we added additional R packages necessary to run the module to the metadata;\nHow we added default values for parameters and inputs explicitly used by the modules (others like .plotInterval were left as NA). The exception was the studyAreaRas input object for which we do not provide a default. However, we added a code check in .inputObject that stops interrupts R if this object is not in sim (see Protect yourself and others from common mistakes/problems)\nHow we use the function prepInputs to do most of the heavy-lifting of downloading data and spatial pre-processing. This function is able to recognize whether the data has already been downloaded, and can cache all spatial processing tasks (see Caching). In some cases, we wrapped prepInputs in a Map call to loop through several URLs and download and pre-process many data layers. This Map call can also be cached with Cache.\nHow we use the function Plots to control plotting to the screen device and/or save to image files depending on the P(sim)$.plots argument. Note that Plots works best with functions that output ggplot objects, or that are compatible with quickPlot::Plot.\nThe fact that neither module depends on the other. This is not a required feature of data modules, but just so happens to be the case in this example. In fact, in more complex modelling frameworks, like the LandR model [@BarrosEtAlinreview], we often have several data modules that depend on each other (e.g., LandR Biomass_speciesData sources and processes tree species percent cover data that is used by LandR Biomass_borealDataPrep to estimate several parameters for the forest landscape simulation model LandR Biomass_core).\nHow we export objects created within the module functions to sim. Without doing so, these objects are lost after the function is executed.\n\n\n\n\n2.2.2 Prediction module\nWe show below the .R script for the projectSpeciesDist module. This module depends entirely on the other two, as we did not provide any default input objects in the .inputObjects function. This is, of course, not good practice, but again we warn the user early on (in the .inputObjects function) if the module cannot find the necessary inputs.\nThis module fits a machine learning SDM using the MaxEnt algorithm implemented in the dismo package. We recommend having a look at this guide to learn about fitting SDMs with dismo and more. Before fitting the SDM, the module converts any non-binary species data into presences and absences.\nThe main outputs are species distribution projections in the form of plots and a stacked raster layer (sppDistProj) and the fitted SDM object.\n\n\nCode\n## Everything in this file and any files in the R directory are sourced during `simInit()`;\n## all functions and objects are put into the `simList`.\n## To use objects, use `sim$xxx` (they are globally available to all modules).\n## Functions can be used inside any function that was sourced in this module;\n## they are namespaced to the module, just like functions in R packages.\n## If exact location is required, functions will be: `sim$.mods$&lt;moduleName&gt;$FunctionName`.\ndefineModule(sim, list(\n  name = \"projectSpeciesDist\",\n  description = \"\",\n  keywords = \"\",\n  authors = structure(list(list(given = c(\"Ceres\"), family = \"Barros\", \n                                role = c(\"aut\", \"cre\"), email = \"ceres.barros@ubc.ca\", comment = NULL)), class = \"person\"),\n  childModules = character(0),\n  version = list(projectSpeciesDist = \"1.0.0\"),\n  timeframe = as.POSIXlt(c(NA, NA)),\n  timeunit = \"year\",\n  citation = list(\"citation.bib\"),\n  documentation = list(\"README.md\", \"projectSpeciesDist.Rmd\"), ## same file\n  reqdPkgs = list(\"SpaDES.core (&gt;=2.0.2)\",\n                  \"caret\", \"data.table\", \"dismo\",\n                  \"ggplot2\", \"rJava\", \"rasterVis\"),\n  parameters = bindrows(\n    #defineParameter(\"paramName\", \"paramClass\", value, min, max, \"parameter description\"),\n    defineParameter(\"predVars\", \"character\", c(\"BIO1\", \"BIO4\", \"BIO12\", \"BIO15\"), NA, NA,\n                    \"Predictors used in statistical model.\"),\n    defineParameter(\"presThresh\", \"numeric\", 10, 0, NA,\n                    paste(\"Minimum threshold for the species to be considered present, when\",\n                          \" `sppAbundanceDT` contains non binary species data (e.g. %, proportions,\",\n                          \"or abundance data). By default 10% cover.\")),\n    defineParameter(\"statModel\", \"character\", \"MaxEnt\", NA, NA,\n                    paste(\"What statitical algorith to use. Currently only 'MaxEnt' and 'GLM' are\",\n                          \"supported. 'MaxEnt will fit a MaxEnt model using dismo::maxent; 'GLM'\",\n                          \"will fit a generalised linear model with a logit link using\",\n                          \"glm(..., family = 'binomial'). In both cases all predictor variables are used,\",\n                          \"and for GLM only additive effects are considered.\" )),\n    defineParameter(\".plots\", \"character\", \"screen\", NA, NA,\n                    \"Used by Plots function, which can be optionally used here\"),\n    defineParameter(\".plotInitialTime\", \"numeric\", start(sim), NA, NA,\n                    \"Describes the simulation time at which the first plot event should occur.\"),\n    ## .seed is optional: `list('init' = 123)` will `set.seed(123)` for the `init` event only.\n    defineParameter(\".seed\", \"list\", list(), NA, NA,\n                    \"Named list of seeds to use for each event (names).\"),\n    defineParameter(\".useCache\", \"logical\", FALSE, NA, NA,\n                    \"Should caching of events or module be used?\")\n  ),\n  inputObjects = bindrows(\n    #expectsInput(\"objectName\", \"objectClass\", \"input object description\", sourceURL, ...),\n    expectsInput(\"climateDT\", \"data.table\",\n                 desc = paste(\"A data.table with as many columns as the climate covariates\",\n                              \"used in the species distribution model and 'year' column describing\",\n                              \"the simulation year to which the data corresponds.\")),\n    expectsInput(\"sppAbundanceDT\", \"data.table\",\n                 desc = paste(\"A species abundance data. Converted to presence/absence data, if not binary.\",\n                              \"By default a table with % species cover.\")),\n    expectsInput(\"studyAreaRas\", objectClass = \"SpatRaster\",\n                 desc = \"A binary raster of the study area\")\n  ),\n  outputObjects = bindrows(\n    #createsOutput(\"objectName\", \"objectClass\", \"output object description\", ...),\n    createsOutput(objectName = \"sppDistProj\", objectClass = \"SpatRaster\",\n                  desc = paste(\"Species distribution projections - raw predictions.\",\n                               \"Each layer corresponds to a prediciton year\")),\n    createsOutput(objectName = \"evalOut\", objectClass = \"ModelEvaluation\",\n                  desc = paste(\"`sdmOut` model evaluation statistics. Model evaluated on the 20% of\",\n                               \"the data. See `?dismo::evaluation`.\")),\n    createsOutput(objectName = \"sdmData\", objectClass = \"data.table\",\n                  desc = \"Input data used to fit `sdmOut`.\"),\n    createsOutput(objectName = \"sdmOut\", objectClass = c(\"MaxEnt\", \"glm\"),\n                  desc = paste(\"Fitted species distribution model. Model fitted on 80%\",\n                               \"of `sdmData`, with remaining 20% used for evaluation.\")),\n    createsOutput(objectName = \"thresh\", objectClass = \"numeric\",\n                  desc = paste(\"Threshold of presence that maximises the sum of the sensitivity\",\n                               \"(true positive rate) and specificity (true negative rate).\",\n                               \"See `dismo::threshold(..., stat = 'spec_sens')`.\"))\n  )\n))\n\n## event types\n#   - type `init` is required for initialization\n\ndoEvent.projectSpeciesDist = function(sim, eventTime, eventType) {\n  switch(\n    eventType,\n    init = {\n      ### check for more detailed object dependencies:\n      ### (use `checkObject` or similar)\n      \n      # do stuff for this event\n      sim &lt;- SDMInit(sim)\n      \n      # schedule future event(s)\n      sim &lt;- scheduleEvent(sim, start(sim), \"projectSpeciesDist\", \"fitSDM\")\n      sim &lt;- scheduleEvent(sim, start(sim), \"projectSpeciesDist\", \"evalSDM\",\n                           eventPriority = .normal() + 1)\n      sim &lt;- scheduleEvent(sim, start(sim), \"projectSpeciesDist\", \"projSDM\",\n                           eventPriority = .normal() + 2)\n      sim &lt;- scheduleEvent(sim, P(sim)$.plotInitialTime, \"projectSpeciesDist\", \"plotProjSDM\",\n                           eventPriority = .normal() + 3)\n      \n    },\n    fitSDM = {\n      # ! ----- EDIT BELOW ----- ! #\n      sim &lt;- fitSDMEvent(sim)\n      # ! ----- STOP EDITING ----- ! #\n    },\n    evalSDM = {\n      # ! ----- EDIT BELOW ----- ! #\n      sim &lt;- evalSDMEvent(sim)\n      # ! ----- STOP EDITING ----- ! #\n    },\n    projSDM = {\n      # ! ----- EDIT BELOW ----- ! #\n      sim &lt;- projSDMEvent(sim)\n      \n      sim &lt;- scheduleEvent(sim, time(sim) + 1L, \"projectSpeciesDist\", \"projSDM\")\n      # ! ----- STOP EDITING ----- ! #\n    },\n    plotProjSDM = {\n      # ! ----- EDIT BELOW ----- ! #\n      plotProjEvent(sim)\n      \n      sim &lt;- scheduleEvent(sim, time(sim) + 1L, \"projectSpeciesDist\", \"plotProjSDM\",\n                           eventPriority = .normal() + 1)\n      \n      # ! ----- STOP EDITING ----- ! #\n    },\n    warning(paste(\"Undefined event type: \\'\", current(sim)[1, \"eventType\", with = FALSE],\n                  \"\\' in module \\'\", current(sim)[1, \"moduleName\", with = FALSE], \"\\'\", sep = \"\"))\n  )\n  return(invisible(sim))\n}\n\n## event functions\n#   - keep event functions short and clean, modularize by calling subroutines from section below.\n\n### template initialization\nSDMInit &lt;- function(sim) {\n  # # ! ----- EDIT BELOW ----- ! #\n  ## at this point we can only have the following columns\n  if (!identical(sort(names(sim$sppAbundanceDT)), sort(c(\"cell\", \"x\", \"y\", \"sppAbund\", \"year\")))) {\n    stop(paste(\"sim$sppAbundanceDT can only have the following columns at the start of year 1:\\n\",\n               paste(c(\"cell\", \"x\", \"y\", \"sppAbund\", \"year\"), collapse = \", \")))\n  }\n  \n  if (length(setdiff(sim$climateDT$cell, sim$sppAbundanceDT$cell)) &gt; 0 ||\n      length(setdiff(sim$sppAbundanceDT$cell, sim$climateDT$cell)) &gt; 0) {\n    stop(\"'cell' columns in `climateDT` and `sppAbundanceDT` have different values\")\n  }\n  \n  if (!P(sim)$statModel %in% c(\"MaxEnt\", \"GLM\")) {\n    stop(\"'statModel' parameter must be 'MaxEnt' or 'GLM'\")\n  }\n  \n  ## a few data cleaning steps to make sure we have presences and absences:\n  sppAbundanceDT &lt;- copy(sim$sppAbundanceDT)\n  if (min(range(sppAbundanceDT$sppAbund)) &lt; 0) {\n    sppAbundanceDT[sppAbund &lt; 0, sppAbund := 0]\n  }\n  \n  if (!all(unique(sppAbundanceDT$sppAbund) %in% c(0, 1))) {\n    message(\"Species data is not binary.\")\n    message(\"Converting values &gt;= P(sim)$presThresh to presences, and &lt; P(sim)$presThresh to absences\")\n    sppAbundanceDT[sppAbund &gt;= P(sim)$presThresh, presAbs := 1]\n    sppAbundanceDT[sppAbund &lt; P(sim)$presThresh, presAbs := 0]\n  }\n  \n  ## join the two datasets - note that there are no input species abundances beyond year 1\n  sim$sdmData &lt;- merge(sim$climateDT, sppAbundanceDT[, .(cell, sppAbund, presAbs, year)],\n                       by = c(\"cell\", \"year\"), all = TRUE)\n  \n  # ! ----- STOP EDITING ----- ! #\n  return(invisible(sim))\n}\n\nfitSDMEvent &lt;- function(sim) {\n  # ! ----- EDIT BELOW ----- ! #\n  ## break data into training and testing subsets\n  dataForFitting &lt;- sim$sdmData[year == time(sim)]\n  \n  if (nrow(dataForFitting) == 0) {\n    stop(paste(\"No data for year\", time(sim), \"provided to fit the model\"))\n  }\n  \n  group &lt;- createDataPartition(dataForFitting$presAbs, p = 0.8, list = FALSE)\n  ## save the the split datasets as internal objects to this module\n  mod$trainData &lt;- dataForFitting[group]\n  mod$testData &lt;-  dataForFitting[-group]\n  \n  if (!any(mod$trainData$presAbs == 0)) {\n    stop(\"Training dataset contains no absences.\")\n  }\n  \n  predVars &lt;- P(sim)$predVars\n  if (P(sim)$statModel == \"MaxEnt\") {\n    sim$sdmOut &lt;- maxent(x = as.data.frame(mod$trainData[, ..predVars]),\n                         p = mod$trainData$presAbs)\n  } else {\n    ## make an additive model with all predictors - avoid using as.formula, which drags the whole environment\n    form &lt;- enquote(paste(\"presAbs ~\", paste(predVars, collapse = \"+\")))\n    sim$sdmOut &lt;- glm(formula = eval(expr = parse(text = form)),\n                      family = \"binomial\", data = mod$trainData)\n  }\n  # ! ----- STOP EDITING ----- ! #\n  return(invisible(sim))\n}\n\nevalSDMEvent &lt;- function(sim) {\n  # ! ----- EDIT BELOW ----- ! #\n  ## validate model\n  predVars &lt;- P(sim)$predVars\n  sim$evalOut &lt;- evaluate(p = mod$testData[presAbs == 1, ..predVars],\n                          a = mod$testData[presAbs == 0, ..predVars],\n                          model = sim$sdmOut)\n  ## save the threshold of presence/absence in an internal object to this module\n  sim$thresh &lt;- threshold(sim$evalOut, 'spec_sens')\n  \n  # ! ----- STOP EDITING ----- ! #\n  return(invisible(sim))\n}\n\nprojSDMEvent &lt;- function(sim) {\n  # ! ----- EDIT BELOW ----- ! #\n  ## predict across the full data and make a map\n  dataForPredicting &lt;- sim$sdmData[year == time(sim)]\n  \n  if (nrow(dataForPredicting) == 0) {\n    stop(paste(\"No data for year\", time(sim), \"provided to calculate predictions\"))\n  }\n  \n  predVars &lt;- P(sim)$predVars\n  preds &lt;- predict(sim$sdmOut, as.data.frame(dataForPredicting[, ..predVars]),\n                   progress = '')\n  sppDistProj &lt;- replace(sim$studyAreaRas, which(!is.na(sim$studyAreaRas[])), preds)\n  names(sppDistProj) &lt;- paste0(\"year\", time(sim))\n  \n  if (is.null(sim$sppDistProj)) {\n    sim$sppDistProj &lt;- sppDistProj\n  } else {\n    sim$sppDistProj &lt;- rast(list(sim$sppDistProj, sppDistProj))\n  }\n  \n  # ! ----- STOP EDITING ----- ! #\n  return(invisible(sim))\n}\n\nplotProjEvent &lt;- function(sim) {\n  # ! ----- EDIT BELOW ----- ! #\n  checkPath(file.path(outputPath(sim), \"figures\"), create = TRUE)\n  \n  if (any(!is.na(P(sim)$.plots))) {\n    \n    ## response plot\n    ## we can't use Plots to plot and save SDM predictions with dismo.\n    ## these are only saved to disk\n    fileSuffix &lt;- paste0(P(sim)$statModel, \".png\")\n    \n    notScreen &lt;- setdiff(P(sim)$.plots, \"screen\")\n    if (any(notScreen != \"png\")) {\n      warning(paste(currentModule(sim), \"only saves to PNG at the moment.\"))\n    }\n    png(file.path(outputPath(sim), \"figures\", paste0(\"SDMresponsePlot_\", fileSuffix)))\n    response(sim$sdmOut)\n    dev.off()\n    \n    ## species projections\n    fileSuffix &lt;- paste0(P(sim)$statModel, \"_Year\", time(sim))\n    clearPlot()\n    rawValsPlot &lt;- sim$sppDistProj[[paste0(\"year\", time(sim))]]\n    Plots(rawValsPlot, fn = plotSpatRaster, types = P(sim)$.plots,\n          usePlot = TRUE, filename = file.path(outputPath(sim), \"figures\", paste0(\"projRawVals_\", fileSuffix)),\n          plotTitle = paste(\"Projected raw values -\", \"year\", time(sim)),\n          xlab = \"Longitude\", ylab = \"Latitude\")\n    \n    PAsPlot &lt;- terra::as.int(sim$sppDistProj[[paste0(\"year\", time(sim))]] &gt; sim$thresh)\n    Plots(PAsPlot, fn = plotSpatRaster, types = P(sim)$.plots,\n          usePlot = TRUE, filename = file.path(outputPath(sim), \"figures\", paste0(\"projPA_\", fileSuffix)),\n          plotTitle = paste(\"Projected presence/absence -\", \"year\", time(sim)),\n          xlab = \"Longitude\", ylab = \"Latitude\")\n  }\n  \n  # ! ----- STOP EDITING ----- ! #\n  return(invisible(sim))\n}\n\n.inputObjects &lt;- function(sim) {\n  #cacheTags &lt;- c(currentModule(sim), \"function:.inputObjects\") ## uncomment this if Cache is being used\n  dPath &lt;- asPath(getOption(\"reproducible.destinationPath\", dataPath(sim)), 1)\n  message(currentModule(sim), \": using dataPath '\", dPath, \"'.\")\n  \n  # ! ----- EDIT BELOW ----- ! #\n  ## check that necessary objects are in the simList or WILL BE supplied  by another module\n  if (!suppliedElsewhere(\"climateDT\") | !suppliedElsewhere(\"sppAbundanceDT\") ) {\n    stop(\"Please provide `climateDT` and `sppAbundanceDT`\")\n  }\n  \n  # ! ----- STOP EDITING ----- ! #\n  return(invisible(sim))\n}\n\n\nWe draw your attention to:\n\nAs we said earlier, we could have added yearly projected values to the sppAbundanceDT table. In this case we probably would have changed this object’s name, since MaxEnt is not modelling species abundance, but probability of occurrence. We suggest this as an exercise to do on your own\nHow links with the data modules are established by declaring data modules’ output objects as expected inputs for this module.\nHow the fitSDM event does not schedule itself (the SDM only needs to be fitted once).\nHow, unlike fitSDM, the projSDM event schedules itself so that model projections are executed for each year of the simulation, provided that there is corresponding environmental data – notice how the functions fitSDMEvent and projSDMEvent both check that there is data for the current year of the simulation (time(sim)).\nHow the fitted model object (sdmOut) and it’s evaluation (evalOut) are both module outputs. This way these objects can not only be used by other events, but also inspected by the user after the simulation is finished (see Transparent models).\n\nYou will notice that this module performs model fitting (i.e., calibration), predictions and model validation. These three components could be broken into three separate modules. As an exercise, we recommend trying to do so on your own.\n\n\n2.2.3 Additional module scripts and functions\nAll functions needed by a module can be coded within the module script. Often they will be located after all the event functions and before the .inputObjects function; however, their exact location is up to the developer.\nFor long, complex modules involving many (potentially long) functions, including all functions within a module’s script quickly makes the script long and hard to maintain. Instead, we recommend that additional (i.e., non-event functions) are put into separate scripts and in the module’s R/ folder. SpaDES will source any scripts contained in this older and associate its objects/functions with the respective module.\nNote that, these functions/objects will only be available to the module where the R/ is located.\nHence, if one or more functions are meant to be shared across modules they will need to either:\n\nbe defined in .GlobalEnv (the global environment – see ?.GlobalEnv) before running simInit;\nbe put it in an R package that is included in the modules’ metadata and installed as other packages – hence the package is in an online repository like GitHub or CRAN;\nbe put it in a local R package that is included in the modules’ metadata and installed (e.g., devtools::install_local) or loaded (e.g. devtools::load_all(\"&lt;pathToPackage&gt;\")) “separately” by the user before, as Require is not able to install local packages.\n\nIn this example, we put the plotting functions called by Plots into separate scripts for each module where they are used. Modules speciesAbundanceData and projectSpeciesDist both have the function plotSpatRaster in a plotSpatRaster.R script saved in their respective R/ folders:\n\n\nCode\n#' Function used to plot SpatRaster\n#' \n#' To be used with Plots\n#' \n#' @param ras a SpatRaster layer\n#' @param title character. Plot title\n#' @param xlab character. X-axis title\n#' @param ylab character. Y-axis title\n#' \n#' @importFrom rasterVis gplot \n#' @importFrom ggplot2 geom_tile scale_fill_brewer coord_equal theme_bw\n\nplotSpatRaster &lt;- function(ras, plotTitle = \"\", xlab = \"x\", ylab = \"y\") {\n    gplot(ras) + geom_tile(aes(fill = value)) + scale_fill_distiller(palette = \"Blues\",\n        direction = 1, na.value = \"grey90\", limits = c(0, 1)) +\n        theme_classic() + coord_equal() + labs(title = plotTitle,\n        x = xlab, y = ylab)\n}\n\n\nThe climateData module uses the function plotSparRasterStk, which is in the plotSparRasterStk.R in its R/ folder:\n\n\nCode\n#' Function used to plot SpatRaster Stacks\n#' \n#' To be used with Plots\n#' \n#' @param stk a SpatRaster stack.\n#' @param title character. Plot title\n#' @param xlab character. X-axis title\n#' @param ylab character. Y-axis title\n#' \n#' @importFrom rasterVis gplot\n#' @importFrom ggplot geom_tile facet_wrap scale_fill_brewer coord_equal\n\nplotSpatRasterStk &lt;- function(stk, plotTitle = \"\", xlab = \"x\",\n    ylab = \"y\") {\n    gplot(stk) + geom_tile(aes(fill = value)) + scale_fill_distiller(palette = \"Blues\",\n        direction = 1, na.value = \"grey90\") + theme_classic() +\n        coord_equal() + facet_wrap(~variable) + labs(title = plotTitle,\n        x = xlab, y = ylab)\n}\n\n\nGo ahead and create these scripts with the functions above and put them in the right R/ folders.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A more realistic example of `SpaDES`</span>"
    ]
  },
  {
    "objectID": "Part2_SDMs.html#running-the-model",
    "href": "Part2_SDMs.html#running-the-model",
    "title": "2  A more realistic example of SpaDES",
    "section": "2.3 Running the model",
    "text": "2.3 Running the model\n\n2.3.1 Ensuring all packages are installed\nAfter the modules are created, we go back to the Part2_SDMs.R script to set up and run the simulation. We first ensure that all module dependencies (and their dependencies and so on) are installed in .libPaths().\nOnly then do we load packages necessary to run the simulation.\nNote that the dismo package (a dependency of the projectSpeciesDist module) needs rJava to run maxent. In turn, rJava needs a working Java installation (Java can be downloaded here). Below you will see that we attempt to warn the user about problems loading rJava, which are likely related to Java not being found on the system.\n\n\nCode\nouts &lt;- SpaDES.project::packagesInModules(modulePath = simPaths$modulePath)  ## gets list of module dependencies\nRequire::Require(c(unname(unlist(outs)),\n                   \"DiagrammeR\"), \n                 require = FALSE,   ## don't load packages\n                 upgrade = FALSE,   ## don't upgrade dependencies\n                 standAlone = TRUE, ## install all dependencies in proj-lib (ignore user/system lib)\n                 purge = TRUE) \n\n## now load packages - SpaDES.core may have been loaded already, which is fine\nRequire::Require(c(\"reproducible\", \"SpaDES.core\", \"SpaDES.experiment\"), \n                 install = FALSE) \n\n## dismo needs a few tweaks to run MaxEnt\nout &lt;- reproducible::preProcess(targetFile = \"maxent.jar\",\n                                url = \"https://github.com/mrmaxent/Maxent/blob/master/ArchivedReleases/3.4.4/maxent.jar?raw=true\",\n                                destinationPath = simPaths$inputPath,\n                                fun = NA)\nfile.copy(out$targetFilePath, file.path(system.file(\"java\", package=\"dismo\"), \"maxent.jar\"),\n          overwrite = TRUE)\n\nout &lt;- require(rJava)\nif (!out) {\n  stop(paste(\"Your Java installation may have problems, please check.\\n\", \n             \"See https://www.java.com/en/download/manual.jsp for Java installation\"))\n}\n\n\n/!\\ ATTENTION /!\\\nWindows can present problems when many packages are installed and further package installations fail. If you see errors like this after restarting R:\nInstalling: glue Detaching is fraught with many potential problems; you may \nhave to restart your session if things aren't working some packages don't seem\nto unload their dlls correctly.\nThese will not be unloaded: ellipsis, vctrs Unloading package bit64 -- \nInstalling glue -- (1 of 1. Estimated time left: ...; est. finish: ...calculating) \nInstalling package into '\\~/R/win-library/4.0' (as 'lib' is unspecified) trying URL\n'&lt;https://cran.rstudio.com/bin/windows/contrib/4.0/glue_1.6.2.zip&gt;' Content type\n'application/zip' length 171858 bytes (167 KB) downloaded 167 KB\n\npackage 'glue' successfully unpacked and MD5 sums checked \nError in unpackPkgZip(foundpkgs[okp, 2L], foundpkgs[okp, 1L], lib, libs_only, : \nERROR: failed to lock directory '\\~\\R\\win-library\\\\4.0' for modifying \nTry removing '\\~\\R\\win-library\\\\4.0/00LOCK'\nIf you encounter this error, delete the problematic file/folder and try again.\nSometimes Require may still unable to automatically install a package and a manual installation from a clean session is the only solution. In the error above, Require only detected that glue was missing during the simInit call, which meant that other packages had been loaded already causing failure when Require attempted the installation. This problem persisted even after we avoided loading terra before running simInit (we make the study area objects prefixing functions with terra::), so glue had to be manually installed.\n\n\n2.3.2 Simulation set-up\nThe simulation folder directories were already set up before creating the modules (see above), but it is still necessary to create a few lists that will be passed to the simInit function, which initializes the simulation. These lists define the modules used in the simulation (simModules), the start and end of the simulation (simTimes), the parameters passed to each module (simParams) and external input objects (simObjects) like the study area (studyAreaRas).\nThe studyAreaRas is created from a random polygon drawn in SW Alberta, Canada, using SpaDES.tools::randomStudyArea. (Figure 2.1).\nWe also define a few useful global options:\n\nreproducible.cachePath and reproducible.destinationPath define the cache directory and the directory where downloaded and processed data will be stored;\nreproducible.useCache and reproducible.useTerra, which will activate caching and the use of the terra package across all Cache and prepInputs function calls.\n\n\n\nCode\n## a few important options:\noptions(reproducible.useCache = TRUE,\n        reproducible.cachePath = simPaths$cachePath,\n        reproducible.destinationPath = simPaths$inputPath, ## all downloaded and pre-processed layers go here\n        reproducible.useTerra = TRUE, ## we want to use the terra R package\n        spades.moduleCodeChecks = FALSE,\n        spades.useRequire = FALSE)  \n\n## list the modules to use\nsimModules &lt;- list(\"speciesAbundanceData\", \"climateData\", \"projectSpeciesDist\")\n\n## Set simulation and module parameters\nsimTimes &lt;- list(start = 1, end = 5, timeunit = \"year\")\n\n## we create two lists of parameters, one using the default MaxEnt\n## the other a GLM\nsimParamsMaxEnt &lt;- list(\n  \"speciesAbundanceData\" = list(\n    \".plots\" = c(\"png\"),\n    \".useCache\" = FALSE\n  ),\n  \"climateData\" = list(\n    \".plots\" = c(\"png\"),\n    \".useCache\" = FALSE\n  ),\n  \"projectSpeciesDist\" = list(\n    \"statModel\" = \"MaxEnt\",\n    \".plots\" = c(\"png\"),\n    \".useCache\" = FALSE\n  )\n)\nsimParamsGLM &lt;- simParamsMaxEnt\nsimParamsGLM$projectSpeciesDist$statModel &lt;- \"GLM\"\n\n## make a random study area.\n##  Here use seed to make sure the same study area is always generated\nstudyArea &lt;- SpaDES.tools::randomStudyArea(size = 1e10, seed = 123)\nstudyAreaRas &lt;- terra::rasterize(studyArea, \n                                 terra::rast(extent = terra::ext(studyArea), \n                                             crs = terra::crs(studyArea, proj = TRUE), \n                                             resolution = 1000))\nsimObjects &lt;- list(\n  \"studyAreaRas\" = studyAreaRas\n)\n\n## Simulation setup - create two simulations, one for MaxEnt another for GLM\n## SpaDES.experiment::experiment2, will take care of subdirectories to store outputs\nmySimMaxEnt &lt;- simInit(times = simTimes, params = simParamsMaxEnt, \n                       modules = simModules, objects = simObjects, \n                       paths = simPaths)\nmySimGLM &lt;- simInit(times = simTimes, params = simParamsGLM, \n                    modules = simModules, objects = simObjects, \n                    paths = simPaths)\n\n\n\n\n\n\n\n\n\n\nFigure 2.1: Study area within Canada.\n\n\n\n\n\nBefore running the simulation we look at the module linkage diagrams produced by moduleDiagram (Figure 2.2)) and objectDiagram (Figure 2.3) to assess whether modules are linked as expected.\n\n\nCode\nmoduleDiagram(mySimMaxEnt)\nobjectDiagram(mySimMaxEnt)\n\n\n\n\n\n\n\n\n\n\nFigure 2.2: Module network diagram.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.3: Module diagram showing module inter-dependencies with object names.\n\n\n\n\n\n\n\n2.3.3 Simulation runs\nTo run the simulation, we can call spades on the output simLists (called mySimMaxEnt and mySimMaxGLM here) generated by simInit, or use experiment2 from the SpaDES.experiment package. experiment2 will run as many simulations as simLists and organise outputs into sub-folders within the simPaths$outputs directory. It can also repeat simulations (rep argument) and parallelise across replicates using future. See ?experiment2 for examples.\nWe advise using spades when running the model for the first time. Passing the argument debug = TRUE will print the progress of the simulation in detail. This helps diagnosing problems when the simulation fails, but also seeing which events are being executed and when particular cache calls are activated.\n\n\nCode\n## run simulation\nclearPlot(force = TRUE)  ## this forces wiping the graphics device and opening a new window\n\n## This runs one simulation and stores outputs in the main\n## 'outputs' folder - not what we want, but good for\n## testing mySimOut &lt;- spades(mySimMaxEnt, debug = TRUE)\n\n## Better to use when spades runs error-free on the\n## simLists\nmyExperiment &lt;- experiment2(MaxEnt = mySimMaxEnt, GLM = mySimGLM,\n    debug = TRUE, replicates = 1, clearSimEnv = FALSE)  ## prevent removing objects from the simLists at the end\n## save outputs\nqs::qsave(myExperiment, file.path(simPaths$outputPath, paste0(\"myExperiment\",\n    \".qs\")))\n\n\nTry to execute the spades call twice to see how much faster it runs after many of the operations have been cached (see also Caching).\nBy default the data modules (speciesAbundanceData and climateData) save figures of the input species and climate layers (Figure 2.4 and Figure 2.5 , respectively).\n\n\n\n\n\n\n\n\nFigure 2.4: Prediction plots. Input Picea glauca percent cover across the landscape. Note that values are converted to presence/absence.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c)\n\n\n\n\n\n\n\n\n\n\n\n(d)\n\n\n\n\n\n\n\nFigure 2.5: Prediction plots. Bioclimatic variables under baseline (year 1) and future conditions.\n\n\n\nThe prediction module also outputs the projections for each climate period automatically ( Figure 2.6 and Figure 2.7 ).\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c)\n\n\n\n\n\n\n\n\n\n\n\n(d)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(e)\n\n\n\n\n\n\n\nFigure 2.6: Prediction plots: Raw predicted values of species probability of occurence under (left to right) baseline climate conditions (first year of simulation), 2021-2040, 2041-2060, 2061-2080 and 2081-2100 climate conditions (second to fifth years of simulation) - using MaxEnt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c)\n\n\n\n\n\n\n\n\n\n\n\n(d)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(e)\n\n\n\n\n\n\n\nFigure 2.7: Prediction plots: Predictions of Picea glauca presence/absence under (left to right) baseline climate conditions (first year of simulation), 2021-2040, 2041-2060, 2061-2080 and 2081-2100 climate conditions (second to fifth years of simulation) - using MaxEnt.\n\n\n\nThe projected layers can also be accessed and plotted via the simList object, as can the model validation results.\nFrom the results we can see that the MaxEnt and GLM predictions do not seem to agree, indicating a potential problem. We may be missing important covariates, interactions, or simply more appropriate algorithms.\nPeruse each model’s estimated coefficients and residuals, and validation results will be a good first step to diagnosing the problem.\n\n\nCode\nmyExperiment$MaxEnt_rep1$sdmOut  ## this links to an html page\n\nsets &lt;- par(mfrow = c(2, 2))\nplot(myExperiment$GLM_rep1$sdmOut)\npar(sets)\n\n## check validation results for the two models\nmyExperiment$MaxEnt_rep1$evalOut\nmyExperiment$GLM_rep1$evalOut\n\n\n\n2.3.3.1 Adding a new climate scenario\nBecause data were linked to the modules (and the forecasting) via the modules’ metadata and inputs, adding a new climate scenario and re-running forecasts is easy.\nTo do so, we need only to change the URLs for the climate layers, by passing a custom projClimateURLs data.table to the climateData module. SpaDES will take care of downloading and processing the new layers, as well as forecasting. Model fitting will also be repeated, even if the baseline data did not change, because the kfold function we use to partition the data into the training and testing subsets randomly assigns cases to each group. If this was not desired, we could set a random seed before running the fitting event (fitSDM) by passing the .seed parameter to the projectSpeciesDist module (e.g., .seed = list(\"fitSDM\" = 123)).\n\n\nCode\n## Run with another climate scenario - the most contrasting\n## scenario to SSP 585 get the original table from one of\n## the simulations and replace the climate scenario\nprojClimateURLs &lt;- copy(mySimMaxEnt$projClimateURLs)\nprojClimateURLs[, `:=`(URL = gsub(\"ssp585\", \"ssp126\", URL), targetFile = gsub(\"ssp585\",\n    \"ssp126\", targetFile))]\n\n## this time we pass the new table or URLs to the modules,\n## so that climate layers are changed\nsimObjects2 &lt;- list(studyAreaRas = studyAreaRas, projClimateURLs = projClimateURLs)\n\nmySimMaxEnt2 &lt;- simInit(times = simTimes, params = simParamsMaxEnt,\n    modules = simModules, objects = simObjects2, paths = simPaths)\nmySimGLM2 &lt;- simInit(times = simTimes, params = simParamsGLM,\n    modules = simModules, objects = simObjects2, paths = simPaths)\n\nmyExperiment2 &lt;- experiment2(MaxEnt = mySimMaxEnt2, GLM = mySimGLM2,\n    debug = TRUE, replicates = 1, clearSimEnv = FALSE)\n## save outputs\nqs::qsave(myExperiment2, file.path(simPaths$outputPath, paste0(\"myExperiment2\",\n    \".qs\")))\n\n\n\n\n2.3.3.2 Proposed exercises\n\ntry changing the climate layers (e.g., use different climate scenarios or General Circulation models) and rerunning predictions;\ntry adding other statistical algorithms;\ntry breaking up the prediction module into three modules: a calibration module, a prediction module and a validation module.\n\nHave fun!\n\n\n2.3.3.3 Making use of simList for reporting\nAnother advantage of having all simulation parameters, inputs and outputs centralised in one object, is that we can easily inspect and manipulated them afterwards, without the need to load separate objects back into R.\nHere we show how we capitalize on this SpaDES feature to create figures of the outputs (Figure 2.8).\n\n\nCode\n## MaxEnt predictions across time and for each climate\n## scenario -------------- combine plots from two distinct\n## simulations in a single figure (the same can be done to\n## compare MaxEnt and GLM, or plot all projections)\n\n## fetch the internal plotting function instead of\n## repeating code here\nplotFun &lt;- myExperiment$GLM_rep1@.envir$.mods$climateData$plotSpatRasterStk\n\n## raw predictions exported by the module\nsppDistProjMaxEnt &lt;- myExperiment$MaxEnt_rep1$sppDistProj\nsppDistProjMaxEnt2 &lt;- myExperiment2$MaxEnt_rep1$sppDistProj\n\n## we convert the raw predictions into presence absence\n## using exported threshold\nsppDistProjMaxEnt_PA &lt;- as.int(myExperiment$MaxEnt_rep1$sppDistProj &gt;\n    myExperiment$MaxEnt_rep1$thresh)\nsppDistProjMaxEnt2_PA &lt;- as.int(myExperiment2$MaxEnt_rep1$sppDistProj &gt;\n    myExperiment2$MaxEnt_rep1$thresh)\n\n## rename layers from plotting\nnames(sppDistProjMaxEnt) &lt;- names(sppDistProjMaxEnt2) &lt;- c(\"2001\",\n    \"2021-2040\", \"2041-2060\", \"2061-2080\", \"2081-2100\")\nnames(sppDistProjMaxEnt_PA) &lt;- names(sppDistProjMaxEnt2_PA) &lt;- c(\"2001\",\n    \"2021-2040\", \"2041-2060\", \"2061-2080\", \"2081-2100\")\n\n## for a simpler plot choose only years 2001, 2041-2060 and\n## 2081-2100\nyrs &lt;- c(\"2001\", \"2041-2060\", \"2081-2100\")\nplotMaxEnt &lt;- plotFun(sppDistProjMaxEnt[[yrs]], xlab = \"Longitude\",\n    y = \"Latitude\", plotTitle = \"MaxEnt raw predictions - SSP 585\") +\n    scale_fill_viridis_c(na.value = \"grey90\", limits = c(0, 1),\n        begin = 0.25)\nplotMaxEnt2 &lt;- plotFun(sppDistProjMaxEnt2[[yrs]], xlab = \"Longitude\",\n    y = \"Latitude\", plotTitle = \"MaxEnt raw predictions - SSP 126\") +\n    scale_fill_viridis_c(na.value = \"grey90\", limits = c(0, 1),\n        begin = 0.25)\nplotMaxEnt_PA &lt;- plotFun(sppDistProjMaxEnt_PA[[yrs]], xlab = \"Longitude\",\n    y = \"Latitude\", plotTitle = \"MaxEnt presence/absence - SSP 585\") +\n    scale_fill_viridis_c(na.value = \"grey90\", limits = c(0, 1),\n        begin = 0.25)\nplotMaxEnt2_PA &lt;- plotFun(sppDistProjMaxEnt2_PA[[yrs]], xlab = \"Longitude\",\n    y = \"Latitude\", plotTitle = \"MaxEnt presence/absence - SSP 126\") +\n    scale_fill_viridis_c(na.value = \"grey90\", limits = c(0, 1),\n        begin = 0.25)\n\n## organise the plots with mildest scenario first It is\n## clear that MaxEnt and GLM do not agree in their\n## prediction\nplotAll &lt;- ggpubr::ggarrange(plotMaxEnt2 + labs(title = expression(bold(\"Scenario - SSP 126\")),\n    y = expression(atop(bold(\"Raw predictions\"), \"Latitude\"))) +\n    theme(legend.title = element_blank(), legend.key.height = unit(3,\n        \"lines\"), plot.title = element_text(hjust = 0.5), plot.margin = margin(0,\n        0, 0, 0)), plotMaxEnt + labs(title = expression(bold(\"Scenario - SSP 585\")),\n    y = expression(atop(bold(\"\"), \"\"))) + theme(plot.title = element_text(hjust = 0.5),\n    plot.margin = margin(0, 0, 0, 0)), plotMaxEnt2_PA + labs(title = expression(bold(\"\")),\n    y = expression(atop(bold(\"Presence/absence\"), \"Latitude\"))) +\n    theme(plot.margin = margin(0, 0, 0, 0)), plotMaxEnt_PA +\n    labs(title = expression(bold(\"\")), y = expression(atop(bold(\"\"),\n        \"\"))) + theme(plot.margin = margin(0, 0, 0, 0)), legend = \"right\",\n    common.legend = TRUE, labels = c(\"a)\", \"b)\", \"c)\", \"d)\"))\n\n## save figure:\nfigDir &lt;- checkPath(file.path(simPaths$outputPath, \"generalFigures\"),\n    create = TRUE)\nggsave(file.path(figDir, \"MaxEntPredictions.png\"), width = 13.5,\n    height = 5.5, units = \"in\", dpi = 300)\n\n\n\n\n\n\n\n\n\n\nFigure 2.8: Adding a new scenario: Predictions of Picea glauca probabilities of presences and presence/absence under (left to right) baseline climate conditions, 2041-2060, and 2081-2100 climate projections under two emission scenarios (SSP 136 and SSP 585, the default) – showing MaxEnt forecasts only.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A more realistic example of `SpaDES`</span>"
    ]
  },
  {
    "objectID": "Part2_SDMs.html#caching",
    "href": "Part2_SDMs.html#caching",
    "title": "2  A more realistic example of SpaDES",
    "section": "2.4 Caching",
    "text": "2.4 Caching\nIn this example, we relied on caching to avoid having to repeat computationally intensive operations. Running the simInit and spades calls a second time (even after restarting R session) was faster and SpaDES informed us of instances where cached objects were being retrieved:\n(...) \nMar05 19:56:53 clmtDt 1 climateData init 1\\\nMar05 19:56:53 clmtDt ...(Object to retrieve (a7816e2d0deb3b29.rds)) Mar05 19:56:53 clmtDt loaded cached result from previous Map call\n(...)\nCaching in SpaDES is managed by the reproducible package, and can be generally broken down into two types: explicitly coded by the module developer, or internal to SpaDES functions.\n\n2.4.1 Explicitly caching operations\nThroughout the data modules we explicitly cached several data preparation operations using the functions Cache and prepInputs from the reproducible package.\nIn brief, Cache searches for a stored (i.e. cached) output of a given function call; if it does not find it, Cache executes the function call, saves its output and saves information about the function inputs and the function’s code. If it does find it, Cache compares the present inputs and function code against their cached counterparts. In case of a mismatch, the function call is executed again and re-cached.\nprepInputs calls Cache internally at several points, notably to cache spatial processing tasks (e.g. projecting and cropping spatial layers to a study area raster). Another great feature of prepInputs is that when it has a source URL for the target file (as when we used prepInputs to download species % cover and climate layers), it first checks whether the data have already been downloaded (and potentially extracted from an archive folder – .zip file). This is not the same thing as caching, but also avoids unnecessary downloads that can be time consuming.\nNote that caching operations involving stochasticity should be avoided, as it will prevent new random outputs from being generated.\nWe recommend exploring the examples available in the Cache and prepInputs R documentation to learn more about their capabilities. In particular, read about showCache, clearCache and the argument userTags, which allow consulting and deleting cached files.\n/!\\ ATTENTION /!\\\nCache does not deal well with the apply family of functions, which is why we used Map (instead of mapply) to iteratively apply prepInputs to several climate layer URLs.\n\n\n2.4.2 Implicit caching of events\nSpaDES offers implicit caching of events via the global parameter .useCache, which comes in the template modules generated by newModule. We call this “implicit” caching, because the developer does not need to add any caching mechanisms to the module code. SpaDES automatically reads the value of the .useCache parameter and activates caching in the module accordingly.\nThis parameter can be used to cache (or not) all or some module events (in their entirety). In our example, we cached have not cached events but passing .useCache = \".inputObjects\" or .useCache = \"init\" would cache these events.\nNotice how loading cached events (last line below) produces a slightly different message from loading other cached operations (second line below):\nMar05 19:58:34 spcsbn 1 speciesAbundanceData init 1\nMar05 19:58:34 spcsbn ...(Object to retrieve (bffbc48cc055c846.rds)) \nMar05 19:58:35 spcsbn loaded cached copy of init event in speciesAbundanceData module.\nWe have noted that terra objects have issues with caching due to the fact that they rely on pointers. This is a behaviour that we started observing in September 2022 and may be resolved by terra developers in the future.\n\n\n2.4.3 Controlling caching without changing module code\nIn addition to the , which controls caching at the module level.\nThe user can turn caching on/off without caching module code via three different mechanisms:\n\nvia the .useCache parameter – as explained above (Implicit caching of events), setting this parameter controls event caching inside a module;\nvia options(\"reproducible.useCache\") – setting this option to TRUE or FALSE in the global environment (.GlobalEnv) will affect all caching (inside and outside SpaDES modules and the simulation);\nvia the argument spades(.useCache = ...) – this argument behaves in the same way as the .useCache module parameter, but supersedes it across all modules (i.e. if spades(..., .useCache = FALSE), caching will be turned off even if a module’s .useCache is TRUE).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A more realistic example of `SpaDES`</span>"
    ]
  },
  {
    "objectID": "Part2_SDMs.html#best-practices",
    "href": "Part2_SDMs.html#best-practices",
    "title": "2  A more realistic example of SpaDES",
    "section": "2.5 Best practices",
    "text": "2.5 Best practices\n\n2.5.1 Reproducible package installation\nWhen sharing code, it is good practice to provide other users with a list of necessary packages (e.g. by listing the sequence of library calls at the start of a script). We go a step further and advise users to provide code that automatically installs all necessary packages at the start of their controller script. In addition all modules should contain a full list of packages that they depend on, and any particular versions necessary. If options(\"spades.useRequire\") is set to TRUE (the default), SpaDES will automatically attempt to install any packages listed across all modules if they are not installed in .libPaths(), or if the installed version (or branch if installing from GitHub) does not correspond to what is listed in the module .R script. Users can also use Require::pkgSnapshot() to save a list of installed packages that can be used later by Require to install all necessary packages in another machine (see example below).\nPlease beware that package installation should be done as much as possible from a clean R session especially in the context of a SpaDES-based project, where each module can potentially have many different dependencies, which have dependencies of their own (see, for instance, how we delayed package loading until after all modules were in place and had their dependencies checked in Part2_SDMs.R)\n\n\nCode\nRequire::pkgSnapshot(\"pkgsnapshot.txt\", libPaths = .libPaths()[1])  ## you should make sure the right .libPath is chosen\n\n## on another machine:\nRequire::Require(packageVersionFile = \"pkgsnapshot.txt\")\n\n## See ?Require::pkgSnapshot() for more examples.\n\n\n\n\n2.5.2 Protect yourself and others from common mistakes/problems\nA developer should put in place code checks, warnings and messages that protect and warn the user against common mistakes or issues. Some of these fall in the category of code assertions – small tests that verify a snippet of code. More complex tests that assess whether the module (or a group of modules) is producing expected results for, e.g., an ecological point of view fall in the category of integration tests. Here, we only talk about code assertions.\nA common assertion is to verify that input format and class conform to what the function expects. If this is not the case, the developer may add a mechanism to correct the faulty inputs (potentially with a warning or message telling the user it did so) or simply stop the computations with a meaningful error. We provide two examples in the climateData module, where the climateInit function checks whether the bioclimatic variable names are consistent between the baseline and projected climate data, and whether their raster layers match.\nOther assertions can prevent undesirable function behaviours, such as the if statement protecting the newModule call in Part2_SDMs.R, or warn the user that something is missing early on, such as the check for studyAreaRas existence in the .inputObjects of the data modules).\nBear in mind that these are just examples assertions and integration tests are as diverse as the code they test.\n\n\n2.5.3 Readable code\nThere are several guides on how to write reader-friendly code. Even if the developer is forever the sole reader of their own code, there are benefits to writing readable code. First, working on it is less tiresome. Second, we quickly forget why we wrote code in a certain away. Code that is well documented and readable is easier to “come back to” and adapt.\nWe follow many of the recommendations by Hadley Wickham, and highlight below those that we find particularly important:\n\nspacing around operators;\nspacing before left parenthesis, except in a function call;\nadding curly braces after if, else, for and function, unless they are very short statements;\nthoroughly commenting the code;\nnaming functions meaningfully and avoiding to re-use function names (e.g. avoid c &lt;- function (...) {}, as c is already a base function).\n\nYou can automatically cleanup and format your code using the styler package. This package provides an Rstudio addin to easily style a block of selected code, or an entire file.\n\n\n2.5.4 Module documentation – module .Rmd\nWhen modules are created using newModule, this function provides a template module .Rmd file that is meant to document the module. The template suggests a few key sections that should be part of any module’s documentation. Notably, an overview of the module and of its inputs, parameters, outputs and general event flow, together with more in-depth descriptions of each of these sections.\nThe documentation may also contain reproducible examples of how a module can be used, although this is not always relevant. For instance, data modules are often meaningless without downstream modules that use their outputs.\nWe invite the reader to see the manual of our forest landscape simulation model LandR Biomass_core, as an example of how we document some of our SpaDES modules.\n\n\n2.5.5 Coding for the future\nWe often make coding decisions that we regret a few months down the line. This is why as module developers, it is a good idea to think about other possible applications of a module or potential expansion avenues. For instance, trying to imagine if the module can be scaled up or transferred to different study areas, may influence the format of expected inputs and of outputs. In our example, we exported the same type of information (species % cover and climate data) as raster layers and as tables, because we could foresee that the tables could be used to store several projections in a more compact format.\n\n\n2.5.6 Transparent models\nModel transparency is not only about using open source code and making it available. Providing easy access to model data, parameters and outputs is also important. For instance, in our example we deliberately exported the fitted statistical model sdmOut, data (sdmData) and evaluation statistics (evalOut) so that they can be more easily inspected by the user, without needing to “dive in” the code.\nSpaDES also offers the ability to save any objects that are exported to the simList object without having to change module code. To do so, the user passes a data.frame of object names and (potentially) the simulation times when they should be saved to the simInit(outputs = ...) argument. Because objects are saved as .rds files by default, any object class can be saved to disk (see ?outputs for more information).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A more realistic example of `SpaDES`</span>"
    ]
  },
  {
    "objectID": "Part2_SDMs.html#additional-notes",
    "href": "Part2_SDMs.html#additional-notes",
    "title": "2  A more realistic example of SpaDES",
    "section": "2.6 Additional notes",
    "text": "2.6 Additional notes\nSpaDES is an extremely powerful family of R packages, whose potential goes well beyond what has been discussed here. We recommend going to the SpaDES webpage to find out more about the SpaDES R modelling platform, upcoming workshops and publications. See also the Predictive Ecology Github repository for a list of all available SpaDES modules and SpaDES-related packages that we maintain.\nWe wish to acknowledge the World Climate Research Programme, which coordinated and promoted CMIP6, and thank the climate modelling groups for producing and making available their model output, the Earth System Grid Federation (ESGF) for archiving the data and providing access, and WorldClim for downscaling and sharing climate projections and preparing bioclimatic variables.\n\n\nHappy SpaDESing!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>A more realistic example of `SpaDES`</span>"
    ]
  },
  {
    "objectID": "References.html",
    "href": "References.html",
    "title": "References",
    "section": "",
    "text": "Barros, C., Luo, Y., Chubaty, A.M., Eddy, I.M.S., Micheletti, T.,\nBoisvenue, C., et al. (n.d.). Empowering ecologists with a\nPERFICT workflow: Seamlessly linking data, parameterization, prediction,\nvalidation and visualization.\n\n\nFick, S.E. & Hijmans, R.J. (2017). WorldClim 2: New 1‐km spatial\nresolution climate surfaces for global land areas. International\nJournal of Climatology, 37, 4302–4315.\n\n\nHijmans, R.J., Phillips, S., Leathwick, J. & Elith, J. (2021). Dismo: Species\ndistribution modeling.\n\n\nSwart, N.C., Cole, J.N.S., Kharin, V.V., Lazare, M., Scinocca, J.F.,\nGillett, N.P., et al. (2019). CCCma CanESM5 model\noutput prepared for CMIP6 ScenarioMIP.\n\n\nThuiller, W., Georges, D., Gueguen, M., Engler, R. & Breiner, F.\n(2021). biomod2: Ensemble platform for species distribution modeling.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "appendices/Part1_Rscript.html",
    "href": "appendices/Part1_Rscript.html",
    "title": "Appendix A — Complete R script to Chapter 1",
    "section": "",
    "text": "Code\noptions(repos = c(\"https://predictiveecology.r-universe.dev/\", \n                  CRAN = \"https://cloud.r-project.org\"))\n\n## decide where you're working\nmainPath &lt;- \"~/SpaDES4Dummies_Part1\"\npkgPath &lt;- file.path(mainPath, \"packages\", version$platform,\n                     paste0(version$major, \".\", strsplit(version$minor, \"[.]\")[[1]][1]))\ndir.create(pkgPath, recursive = TRUE)\n.libPaths(pkgPath, include.site = FALSE) ## install packages in project library (proj-lib)\n\nif (!\"remotes\" %in% installed.packages(lib.loc = pkgPath))\n  install.packages(\"remotes\")\n\nif (!\"Require\" %in% installed.packages(lib.loc = pkgPath) ||\n    packageVersion(\"Require\", lib.loc = pkgPath) &lt; \"0.3.1\") {\n  remotes::install_github(\"PredictiveEcology/Require@2788b023ad191c29346ef8c64df71b937be307e2\",\n                          upgrade = FALSE)\n}\n\nRequire::Require(c(\"SpaDES\", \"DiagrammeR\"), \n                 require = FALSE, upgrade = FALSE, \n                 dependencies = TRUE, standAlone = TRUE) ## automatically downloads all packages in the SpaDES family and their dependencies\n\nlibrary(SpaDES)\n\nsetPaths(cachePath = file.path(mainPath, \"cache\"),\n         inputPath = file.path(mainPath, \"inputs\"),\n         modulePath = file.path(mainPath, \"modules\"),\n         outputPath = file.path(mainPath, \"outputs\"))\n\n## make a list of directory paths and check paths are ok\nsimPaths &lt;- getPaths()\n\n## Let's create a self-contained module that will simulate the species' abundance for any given period of time and frequency.\nif (!dir.exists(file.path(simPaths$modulePath, \"speciesAbundance\"))) {\n  newModule(name = \"speciesAbundance\", path = simPaths$modulePath)\n}\n\nif (!dir.exists(file.path(simPaths$modulePath, \"temperature\"))) {\n  newModule(name = \"temperature\", path = simPaths$modulePath)\n}\n\nif (!dir.exists(file.path(simPaths$modulePath, \"speciesTempLM\"))) {\n  newModule(name = \"speciesTempLM\", path = simPaths$modulePath)\n}\n\n## list the modules to use\nsimModules &lt;- list(\"speciesAbundance\", \"temperature\", \"speciesTempLM\")\n\n## Set simulation and module parameters\nsimTimes &lt;- list(start = 1, end = 10, timeunit = \"year\")\nsimParams &lt;- list(\n  speciesAbundance = list(simulationTimeStep = 1, \n                          .plotInitialTime = 1),\n  temperature = list(simulationTimeStep = 1, \n                     .plotInitialTime = 1),\n  speciesTempLM = list(statsTimestep = 5)\n)\n\n## Simulation setup\nmySim &lt;- simInit(times = simTimes, params = simParams, \n                 modules = simModules, paths = simPaths)\n\nmoduleDiagram(mySim)\n\nobjectDiagram(mySim)\n\n## run simulation\ndev() # on Windows and Mac, this opens external device if using Rstudio, it is faster\nclearPlot()\nmySim2 &lt;- spades(mySim, debug = TRUE)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Complete R script to Chapter 1</span>"
    ]
  },
  {
    "objectID": "appendices/Part2_Rscript.html",
    "href": "appendices/Part2_Rscript.html",
    "title": "Appendix B — Complete R script to Chapter 2",
    "section": "",
    "text": "Code\noptions(repos = c(\"https://predictiveecology.r-universe.dev/\", \n                  CRAN = \"https://cloud.r-project.org\"))\n\nif (getRversion() &lt; \"4.2.1\") {\n  warning(paste(\"dismo::maxent may create a fatal error\",\n                \"when using R version &lt; v4.2.1 and from RStudio.\\n\", \n                \"Please upgrade R, or run this script outside of RStudio.\\n\",\n                \"See https://github.com/rspatial/dismo/issues/13\"))\n}\n\n## decide where you're working\nmainPath &lt;- file.path(\"~/SpaDES4Dummies_Part2\")\npkgPath &lt;- file.path(mainPath, \"packages\", version$platform,\n                     paste0(version$major, \".\", strsplit(version$minor, \"[.]\")[[1]][1]))\ndir.create(pkgPath, recursive = TRUE)\n.libPaths(pkgPath, include.site = FALSE) ## install packages in project library (proj-lib)\n\nif (!\"remotes\" %in% installed.packages(lib.loc = pkgPath))\n  install.packages(\"remotes\")\n\nif (!\"Require\" %in% installed.packages(lib.loc = pkgPath) ||\n    packageVersion(\"Require\", lib.loc = pkgPath) &lt; \"0.3.1.9015\") {\n  remotes::install_github(\"PredictiveEcology/Require@55ec169e654214d86be62a0e13e9a2157f1aa966\",\n                          upgrade = FALSE)\n}\n\n## Notes: \n## 1) if you are working from RStudio and have an older version of base packages like `Rcpp`, `rlang` \n## (and others) installed, you may  need to run the following lines (and code above) directly from R\n## in order to update these base packages\n## 2) Please ensure the appropriate Rtools version is installed (see)\n\n## there seems to be a problem with `ragg` and a forced install solves it\nif (!\"ragg\" %in% installed.packages(lib.loc = pkgPath)) {\n  install.packages(\"ragg\")\n}\n\nRequire::Require(c(\"PredictiveEcology/SpaDES.project@transition (HEAD)\", \n                   \"PredictiveEcology/SpaDES.core@master (HEAD)\",\n                   ## these will be needed later on:\n                   \"ggpubr\",\n                   \"SpaDES.tools\",\n                   \"PredictiveEcology/SpaDES.experiment@75d917b70b892802fed0bbdb2a5e9f3c6772f0ba\"),\n                 require = FALSE,  ## don't load packages yet \n                 upgrade = FALSE, standAlone = TRUE)\n\n\nRequire::Require(\"SpaDES.core\", install = FALSE)  ## load only\nsetPaths(cachePath = file.path(mainPath, \"cache\"),\n         inputPath = file.path(mainPath, \"inputs\"),\n         modulePath = file.path(mainPath, \"modules\"),\n         outputPath = file.path(mainPath, \"outputs\"))\n\nsimPaths &lt;- getPaths() ## check that this is what you wanted\n\n## Let's create a self-contained module that will simulate the species' abundance for any given period of time and frequency.\nif (!dir.exists(file.path(simPaths$modulePath, \"speciesAbundanceData\"))) {\n  newModule(name = \"speciesAbundanceData\", path = simPaths$modulePath)\n}\n\nif (!dir.exists(file.path(simPaths$modulePath, \"climateData\"))) {\n  newModule(name = \"climateData\", path = simPaths$modulePath)\n}\n\nif (!dir.exists(file.path(simPaths$modulePath, \"projectSpeciesDist\"))) {\n  newModule(name = \"projectSpeciesDist\", path = simPaths$modulePath)\n}\n\n## now, let's pretend you've created your modules and each sources a series of other packages\n## it's a good idea to always make sure all necessary module dependencies are installed\n## this is a particularly useful line when sharing your packages with someone else.\nouts &lt;- SpaDES.project::packagesInModules(modulePath = simPaths$modulePath)  ## gets list of module dependencies\nRequire::Require(c(unname(unlist(outs)),\n                   \"DiagrammeR\"), \n                 require = FALSE,   ## don't load packages\n                 upgrade = FALSE,   ## don't upgrade dependencies\n                 standAlone = TRUE, \n                 purge = TRUE) ## install all dependencies in proj-lib (ignore user/system lib)\n\n## now load packages - SpaDES.core may have been loaded already, which is fine\nRequire::Require(c(\"reproducible\", \"SpaDES.core\", \"SpaDES.experiment\"), \n                 install = FALSE) \n\n## dismo needs a few tweaks to run MaxEnt\nout &lt;- preProcess(targetFile = \"maxent.jar\",\n                  url = \"https://github.com/mrmaxent/Maxent/blob/master/ArchivedReleases/3.4.4/maxent.jar?raw=true\",\n                  destinationPath = simPaths$inputPath,\n                  fun = NA)\nfile.copy(out$targetFilePath, file.path(system.file(\"java\", package=\"dismo\"), \"maxent.jar\"),\n          overwrite = TRUE)\n\nout &lt;- require(rJava)\nif (!out) {\n  stop(paste(\"Your Java installation may have problems, please check.\\n\", \n             \"See https://www.java.com/en/download/manual.jsp for Java installation\"))\n}\n## a few important options:\noptions(reproducible.useCache = TRUE,\n        reproducible.cachePath = simPaths$cachePath,\n        reproducible.destinationPath = simPaths$inputPath, ## all downloaded and pre-processed layers go here\n        reproducible.useTerra = TRUE, ## we want to use the terra R package\n        spades.moduleCodeChecks = FALSE,\n        spades.useRequire = FALSE)  \n\n## list the modules to use\nsimModules &lt;- list(\"speciesAbundanceData\", \"climateData\", \"projectSpeciesDist\")\n\n## Set simulation and module parameters\nsimTimes &lt;- list(start = 1, end = 5, timeunit = \"year\")\n\n## we create two lists of parameters, one using the default MaxEnt\n## the other a GLM\nsimParamsMaxEnt &lt;- list(\n  \"speciesAbundanceData\" = list(\n    \".plots\" = c(\"png\"),\n    \".useCache\" = FALSE\n  ),\n  \"climateData\" = list(\n    \".plots\" = c(\"png\"),\n    \".useCache\" = FALSE\n  ),\n  \"projectSpeciesDist\" = list(\n    \"statModel\" = \"MaxEnt\",\n    \".plots\" = c(\"png\"),\n    \".useCache\" = FALSE\n  )\n)\nsimParamsGLM &lt;- simParamsMaxEnt\nsimParamsGLM$projectSpeciesDist$statModel &lt;- \"GLM\"\n\n## make a random study area.\n##  Here use seed to make sure the same study area is always generated\nstudyArea &lt;- SpaDES.tools::randomStudyArea(size = 1e10, seed = 123)\nstudyAreaRas &lt;- terra::rasterize(studyArea, \n                                 terra::rast(extent = terra::ext(studyArea), \n                                             crs = terra::crs(studyArea, proj = TRUE), \n                                             resolution = 1000))\nsimObjects &lt;- list(\n  \"studyAreaRas\" = studyAreaRas\n)\n\n## Simulation setup - create two simulations, one for MaxEnt another for GLM\n## SpaDES.experiment::experiment2, will take care of subdirectories to store outputs\nmySimMaxEnt &lt;- simInit(times = simTimes, params = simParamsMaxEnt, \n                       modules = simModules, objects = simObjects, \n                       paths = simPaths)\nmySimGLM &lt;- simInit(times = simTimes, params = simParamsGLM, \n                    modules = simModules, objects = simObjects, \n                    paths = simPaths)\n\nmoduleDiagram(mySimMaxEnt)\nobjectDiagram(mySimMaxEnt)\n\n## run simulation\nclearPlot(force = TRUE)   ## this forces wiping the graphics device and opening a new window\n\n## This runs one simulation and stores outputs in the main 'outputs' folder \n## - not what we want, but good for testing\n# mySimOut &lt;- spades(mySimMaxEnt, debug = TRUE)  \n\n## Better to use when spades runs error-free on the simLists\nmyExperiment &lt;- SpaDES.experiment::experiment2(MaxEnt = mySimMaxEnt, \n                                               GLM = mySimGLM, \n                                               debug = TRUE, \n                                               replicates = 1,\n                                               clearSimEnv = FALSE)   ## prevent removing objects from the simLists at the end\n## save outputs\nqs::qsave(myExperiment, file.path(simPaths$outputPath, paste0(\"myExperiment\", \".qs\")))\n\n## check models\ntryCatch(myExperiment$MaxEnt_rep1$sdmOut)   ## this links to an html page\nsets &lt;- par(mfrow = c(2,2))\nplot(myExperiment$MaxEnt_rep1$sdmOut)\npar(sets)\n\n## check validation results for the two models\nmyExperiment$MaxEnt_rep1$evalOut\nmyExperiment$GLM_rep1$evalOut\n\n\n## Run with another climate scenario - the most contrasting scenario to SSP 585\n## get the original table from one of the simulations and replace the climate scenario\nprojClimateURLs &lt;- copy(mySimMaxEnt$projClimateURLs)\nprojClimateURLs[, `:=`(URL = gsub(\"ssp585\", \"ssp126\", URL),\n                       targetFile = gsub(\"ssp585\", \"ssp126\", targetFile))]\n\n## this time we pass the new table or URLs to the modules, so that climate layers are changed\nsimObjects2 &lt;- list(\n  \"studyAreaRas\" = studyAreaRas,\n  \"projClimateURLs\" = projClimateURLs\n)\n\nmySimMaxEnt2 &lt;- simInit(times = simTimes, params = simParamsMaxEnt, \n                        modules = simModules, objects = simObjects2, \n                        paths = simPaths)\nmySimGLM2 &lt;- simInit(times = simTimes, params = simParamsGLM, \n                     modules = simModules, objects = simObjects2, \n                     paths = simPaths)\n\nmyExperiment2 &lt;- experiment2(MaxEnt = mySimMaxEnt2, \n                             GLM = mySimGLM2, \n                             debug = TRUE, \n                             replicates = 1,\n                             clearSimEnv = FALSE)\n## save outputs\nqs::qsave(myExperiment2, file.path(simPaths$outputPath, paste0(\"myExperiment2\", \".qs\")))\n\n## MaxEnt predictions across time and for each climate scenario --------------\n## combine plots from two distinct simulations in a single figure\n## (the same can be done to compare MaxEnt and GLM, or plot all projections)\n\n## fetch the internal plotting function instead of repeating code here\nplotFun &lt;- myExperiment$GLM_rep1@.envir$.mods$climateData$plotSpatRasterStk\n\n## raw predictions exported by the module\nsppDistProjMaxEnt &lt;- myExperiment$MaxEnt_rep1$sppDistProj\nsppDistProjMaxEnt2 &lt;- myExperiment2$MaxEnt_rep1$sppDistProj\n\n## we convert the raw predictions into presence absence\n## using exported threshold\nsppDistProjMaxEnt_PA &lt;- as.int(myExperiment$MaxEnt_rep1$sppDistProj &gt; myExperiment$MaxEnt_rep1$thresh)\nsppDistProjMaxEnt2_PA &lt;- as.int(myExperiment2$MaxEnt_rep1$sppDistProj &gt; myExperiment2$MaxEnt_rep1$thresh)\n\n## rename layers from plotting\nnames(sppDistProjMaxEnt) &lt;- names(sppDistProjMaxEnt2) &lt;- c(\"2001\", \"2021-2040\", \"2041-2060\", \"2061-2080\", \"2081-2100\")\nnames(sppDistProjMaxEnt_PA) &lt;- names(sppDistProjMaxEnt2_PA) &lt;- c(\"2001\", \"2021-2040\", \"2041-2060\", \"2061-2080\", \"2081-2100\")\n\n## for a simpler plot choose only years 2001, 2041-2060 and 2081-2100\nyrs &lt;- c(\"2001\", \"2041-2060\", \"2081-2100\")\nplotMaxEnt &lt;- plotFun(sppDistProjMaxEnt[[yrs]], \n                      xlab = \"Longitude\", y = \"Latitude\",\n                      plotTitle = \"MaxEnt raw predictions - SSP 585\") +\n  scale_fill_viridis_c(na.value = \"grey90\", limits = c(0,1), begin = 0.25)\nplotMaxEnt2 &lt;- plotFun(sppDistProjMaxEnt2[[yrs]], \n                       xlab = \"Longitude\", y = \"Latitude\",\n                       plotTitle = \"MaxEnt raw predictions - SSP 126\") +\n  scale_fill_viridis_c(na.value = \"grey90\", limits = c(0,1), begin = 0.25)\nplotMaxEnt_PA &lt;- plotFun(sppDistProjMaxEnt_PA[[yrs]], \n                         xlab = \"Longitude\", y = \"Latitude\",\n                         plotTitle = \"MaxEnt presence/absence - SSP 585\") +\n  scale_fill_viridis_c(na.value = \"grey90\", limits = c(0,1), begin = 0.25)\nplotMaxEnt2_PA &lt;- plotFun(sppDistProjMaxEnt2_PA[[yrs]], \n                          xlab = \"Longitude\", y = \"Latitude\",\n                          plotTitle = \"MaxEnt presence/absence - SSP 126\") +\n  scale_fill_viridis_c(na.value = \"grey90\", limits = c(0,1), begin = 0.25)\n\n## organise the plots with mildest scenario first\n## It is clear that MaxEnt and GLM do not agree in their prediction\nplotAll &lt;- ggpubr::ggarrange(plotMaxEnt2 + labs(title = expression(bold(\"Scenario - SSP 126\")),\n                                                y = expression(atop(bold(\"Raw predictions\"), \"Latitude\"))) +\n                               theme(legend.title = element_blank(), legend.key.height = unit(3, \"lines\"),\n                                     plot.title = element_text(hjust = 0.5), plot.margin = margin(0,0,0,0)), \n                             plotMaxEnt + labs(title = expression(bold(\"Scenario - SSP 585\")),\n                                               y = expression(atop(bold(\"\"), \"\"))) +\n                               theme(plot.title = element_text(hjust = 0.5), plot.margin = margin(0,0,0,0)),\n                             plotMaxEnt2_PA + labs(title = expression(bold(\"\")),\n                                                   y = expression(atop(bold(\"Presence/absence\"), \"Latitude\"))) +\n                               theme(plot.margin = margin(0,0,0,0)), \n                             plotMaxEnt_PA + labs(title = expression(bold(\"\")),\n                                                  y = expression(atop(bold(\"\"), \"\"))) +\n                               theme(plot.margin = margin(0,0,0,0)), \n                             legend = \"right\", common.legend = TRUE, labels = c(\"a)\", \"b)\", \"c)\", \"d)\"))\nfigDir &lt;- checkPath(file.path(simPaths$outputPath, \"generalFigures\"), create = TRUE)\nggsave(file.path(figDir, \"MaxEntPredictions.png\"), width = 13.5, height = 5.5, units = \"in\", dpi = 300)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Complete R script to Chapter 2</span>"
    ]
  }
]
---
title: "SpaDES 4 Dummies"
author: "Ceres"
date: "November 27, 2017"
output: html_document
---

## a VERY simple example of SpaDES awesomeness

This guide will take you through how to start your own model using SpaDES. It assumes you have already installed SpaDES and that it is working in your machine. If you haven't done this yet, please have a look at [this gist](https://gist.github.com/tati-micheletti/1de7505cdd387fe997f127f13eeb4393) to bypass known issues.


### The example
Let's imagine we wnat to understant whether the abundance of a species is statitically related with temperature. Both the abundance data and the temperature data are being constanty updated. Also, we want to have the possibility of analysing the relationship between the two iteratively, without needing to constantly change our script to account for the new data inputs.
In this example the abundance and temperature data are being updated by a simulation model.

### Before...
If we use R to develop our species abundance and temperature simulation models in the 'conventional way', we'll probably have a script were everything happens - the simulations and data analysis. At most, we would have a main script that sources others that contain useful functions, or are doing the simulations and data treatment/analysis separately. If you already use R like this, you'll find that the SpaDES way of thinking is similar. So why use it? Because it makes changing, adapting and sharing your code - or modules - much easier. 

Still don't believe me? Okay, let's solve our problem using the conventional way:

```{r the_r_way}
suppressMessages(library(raster))

## Template raster
r <- raster(nrows = 100, ncols = 100, xmn = -50, xmx = 50, ymn = -50, ymx = 50)

## SPECIES ABUNDANCE "SIMULATIONS"
## Our VERY simple "simulation" model merely generates rasters that follows a Gaussian distribution
abundance_model <- function(r, Time) {
  abund_outputs <- list()
  for(t in 1:Time) { 
    abund_outputs[[t]] <- SpaDES.tools::gaussMap(r, scale = 100, var = 0.03) 
  }
  return(abund_outputs)
}

## Lenght of the simulation (or simply the number of model iterations)
Time <- 10

## Run the model nad plot results
abundance <- abundance_model(r = r, Time = Time)
plot(stack(abundance))

## TEMPERATURE "SIMULATIONS"
## The temperature simulation model will be almost the same as the vegetation one - remember this is a dummy example ;)
r <- raster(nrows = 100, ncols = 100, xmn = -50, xmx = 50, ymn = -50, ymx = 50)
temp_model <- function(r, Time) {
  temp_outputs <- list()
  for(t in 1:Time) { 
    temp_outputs[[t]] <- SpaDES.tools::gaussMap(r, scale = 100, var = 0.1) 
  }
  return(temp_outputs)
}

## Lenght of the simulation (or simply the number of model iterations)
Time <- 10

## Run the model
temperature <- temp_model(r = r, Time = Time)
plot(stack(temperature))

## DATA ANALYSIS
stats_analysis <- function(Data){
  lm1 <- lm(abund ~ temp, data = Data)
  plot(Data$abund ~ Data$temp, xlab = "Temp.", ylab = "Species abundance")
  abline(a = lm1$coefficients["(Intercept)"], b = lm1$coefficients["temp"], lwd = 2, col = "blue")
}

par_sets <- par(mfrow = c(2, 5))
for(t in 1:Time){
  outputdata <- data.frame(abund = abundance[[t]][], temp = temperature[[t]][])
  stats_analysis(Data = outputdata)
}
```

```{r, echo = FALSE}
par(par_sets)
```


### After...
Let's now transform the example above using the SpaDES approach. I like to start by creating a *global.R* script (you can call it whatever you want, though) that will load the SpaDES libraries and run SpaDES simulations.

```{r globalscript, eval=FALSE}
suppressMessages(library(SpaDES))  ## should automatically download all packages in the SpaDES family and their dependencies

## decide where you're working
setPaths(cachePath = "cache",
         inputPath = "inputs",
         modulePath = "m",
         outputPath = "outputs")
getPaths() ## check that this is what you wanted

## Let's create a self-contained module that will simulate the species' abundance for any given period of time and frequency.
# newModule(name = "speciesAbundance", path = getPaths()$modulePath)

```

You will notice that `newModule` has created a module folder inside */m* that contains both the module *.R* script template, as well as the documentation template (the *.Rmd* file). Although we will not be discussing the .Rmd file, please bear in mind that this is a **fundamental** part of creating a reproducible and transparent module. The documentation should contain not only the description of the module, but also some simple examples of what it can do.
`newModule` also created the folder */data* where data necessary to the module should be put in, and the folder */tests* that may contain testing scripts. We won't be using neither of them in this example. 

/!\\ Attention /!\\ : `newModule` should only be run once, or separately in the console, otherwise you may lose your module edits by re-running it again.

Now go ahead and open the *speciesAbundance.R* script. I know, I know... It seems confusing and there's a lot of stuff in that template, but bear with me! Let's break it down:

The first "bit" of code is basically defining the module metadata. It will allow you to define who the author is, keywords that describe your module and the module(s) and package(s) version(s). It will also define the inputs that the module requires and the outputs it produces. Inputs for this module are produced in the `init` event (see below) and the outputs are the abundance rasters (produced during the `abundanceSim` event). 
You'll notice that I have removed several parameters that we don't need (like save parameters) and that there are no input parameters needed. If you are unsure of what input and output parameters are in the context of a module, a good rule of thumb is that inputs are all `sim$...` objects that appear to the **right-hand side** of a "<-", whereas output parameters appear to the **left-hand side**.

Here's how I defined the module:

```{r abund_module, eval=FALSE}
defineModule(sim, list(
  name = "speciesAbundance",
  description = "Species abundance simulator",
  keywords = c("species", "abundance", "gaussian", "spatial"),
  authors = person("Mr.", "Me", email = "mr.me@example.com", role = c("aut", "cre")),
  childModules = character(0),
  version = list(SpaDES.core = "0.1.0", speciesAbundance = "0.0.1", SpaDES.addins = "0.1.0", SpaDES.tools = "0.1.0"),
  # spatialExtent = raster::extent(rep(NA_real_, 4)),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = list("README.txt", "speciesAbundance.Rmd"),
  reqdPkgs = list("raster"),
  parameters = rbind(
    # defineParameter("paramName", "paramClass", value, min, max, "parameter description"),
    defineParameter("simulationTimeStep", "numeric", 1, NA, NA, "This describes the simulation time step interval"),
    defineParameter(".plotInitialTime", "numeric", 1, NA, NA, "This describes the simulation time at which the first plot event should occur"),
    defineParameter(".plotInterval", "numeric", 1, NA, NA, "This describes the simulation time interval between plot events")
  ),
  inputObjects = bind_rows(
    #expectsInput("objectName", "objectClass", "input object description", sourceURL, ...),
    expectsInput("r", "RasterLayer", "A template raster for abundance and speciesAbundance simulations", sourceURL = NA)
  ),
  outputObjects = bind_rows(
    #createsOutput("objectName", "objectClass", "output object description", ...),
    createsOutput("abundRasters", "RasterLayer", "Raster layer of species abundance at any given year")
  )
))

```

Now the rest of the script determines the event sequence - remember SpaDES = Spatial Descrete Event Simulator - and defines the events themselves. The `init` (initialisation) event is **mandatory**, the others are not. `SpaDES` knows how to deal with the `init` event. For example, it knows that the `init`'s of all active modules will be executed first. The other in which this happens is automatically determined by inter-module dependencies (i.e. if modules require inputs that are the outputs of other modules). If there are no inter-module dependencies the order is determined by the other in which modules are listed in the *global.R* script.
Since we are only interested in simulating and plotting species abundances, we can go ahead and remove unnecessary events from the script. I have kept the initialisaton, plotting and abundance simulation events.

Let's look at the **event functions** first (those that come after `doEvent.speciesAbundance`). Note that `Init` became `abundanceInit`, `Plot` became `abundancePlot` and `event1` became `abundanceSim`.

Initialisation function:
```{r abund_module2, eval = FALSE}
abundanceInit <- function(sim) {
  ## Template raster
  sim$r <- raster(nrows = 100, ncols = 100, xmn = -50, xmx = 50, ymn = -50, ymx = 50)
  
  ## create storage list of species abundance
  sim$abundRasters <- list()
  
  return(invisible(sim))
}
```
In the initialisation, we are creating a template raster 

Abundance simulation event function:
```{r abund_module3, eval = FALSE}
abundanceSim <- function(sim) {
  ## Generate species abundances - our "simulation"
  sim$abundRasters[[time(sim)]] <- sim$abundance_model(ras = sim$r)
  
  return(invisible(sim))
}
```

Plotting event function:
```{r abund_module4, eval = FALSE}
abundancePlot <- function(sim) {
  ## plot abundances
  Plot(sim$abundRasters[[time(sim)]], 
       title = paste0("Species abundance\nat time ", time(sim)))
  
  return(invisible(sim))
}
```

INTEGRATE 28NOV CHANGES HERE



***********
Now go ahead and repeat the same steps to create a second module that will generate yearly temperatures. Apart from changing the objects and functions names, I have also included the template raster `r` as an input object for the temperature module. This avoids repeating the creation of the template raster, which may not seem like a big deal in our example, but it can be if you're generating heavy objects, or relying on functions that take a while to run.
Here's how my final *temperature.R* script looks like:

```{r temp_module, eval = FALSE}
defineModule(sim, list(
  name = "temperature",
  description = "Temperature simulator",
  keywords = c("temperature", "gaussian", "spatial"),
  authors = person("Mr.", "Me", email = "mr.me@example.com", role = c("aut", "cre")),
  childModules = character(0),
  version = list(SpaDES.core = "0.1.0", speciesAbundance = "0.0.1", temperature = "0.0.1", SpaDES.addins = "0.1.0", SpaDES.tools = "0.1.0"),
  spatialExtent = raster::extent(rep(NA_real_, 4)),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = list("README.txt", "temperature.Rmd"),
  reqdPkgs = list("raster"),
  parameters = rbind(
    #defineParameter("paramName", "paramClass", value, min, max, "parameter description"),
    defineParameter("simulationTimeStep", "numeric", 1, NA, NA, "This describes the simulation time step interval"),
    defineParameter(".plotInitialTime", "numeric", 1, NA, NA, "This describes the simulation time at which the first plot event should occur"),
    defineParameter(".plotInterval", "numeric", 1, NA, NA, "This describes the simulation time interval between plot events")
  ),
  inputObjects = bind_rows(
    #expectsInput("objectName", "objectClass", "input object description", sourceURL, ...),
    expectsInput("r", "RasterLayer", "Template raster")
  ),
  outputObjects = bind_rows(
    #createsOutput("objectName", "objectClass", "output object description", ...),
    createsOutput("tempRasters",  "list", "List of raster layers of temperature at any given year")
  )
))

## event types
#   - type `init` is required for initialiazation

doEvent.temperature = function(sim, eventTime, eventType, debug = FALSE) {
  switch(
    eventType,
    init = {
      ## do stuff for this event
      sim <- sim$temperatureInit(sim)
      
      ## schedule future event(s)
      sim <- scheduleEvent(sim = sim, eventTime = start(sim), moduleName = "temperature", eventType = "SimulTemp")
      sim <- scheduleEvent(sim = sim, eventTime = P(sim)$.plotInitialTime, moduleName = "temperature", eventType = "plot")
    },
    plot = {
      ## do stuff for this event
      sim <- sim$temperaturePlot(sim)
      
      ## schedule future event(s)
      sim <- scheduleEvent(sim = sim, eventTime = P(sim)$.plotInterval, moduleName = "temperature", eventType = "plot")
    },
    SimulTemp = {
      ## do stuff for this event
      sim <- sim$temperatureSim(sim)
      
      ## schedule future event(s)
      sim <- scheduleEvent(sim = sim, eventTime = time(sim)+ P(sim)$simulationTimeStep, moduleName = "temperature", eventType = "SimulTemp")
    },
    warning(paste("Undefined event type: '", current(sim)[1, "eventType", with = FALSE],
                  "' in module '", current(sim)[1, "moduleName", with = FALSE], "'", sep = ""))
  )
  return(invisible(sim))
}

## This is the 'init' event:
temperatureInit <- function(sim) {
  ## create storage list of species temperature
  sim$tempRasters <- list()
  
  return(invisible(sim))
}

## This is the plotting event funciton
temperaturePlot <- function(sim) {
  ## plot temperature
  Plot(sim$tempRasters[[time(sim)]], 
       title = paste0("Temperature\nat time ", time(sim)))
  
  return(invisible(sim))
}

## This is the temperature simulation event function
temperatureSim <- function(sim) {
  ## Generate temperature - our "updated data"
  sim$tempRasters[[time(sim)]] <- sim$temperature_model(ras = sim$r)
  
  return(invisible(sim))
}

## This is not an event, but a function that we define separately 
## and that contains our "simulation model"
temperature_model <- function(ras) {
  temp_outputs <- SpaDES.tools::gaussMap(ras, scale = 100, var = 0.01) 
  return(temp_outputs)
}

```

Our third and last module will be used to run the statistical analysis at each year, after the abundances and temperatures are generated. Hence, it'll depend on the outputs of the `speciesAbundance` and the `temperature` modules. We'll call it `speciesTempLM`. The interest of keeping the statistical analysis in a separate module is on the fact that it allows us to easily swap and compare different statistical models to analyse our data if we want to - eiher by chaging the module code, or by having other modules with different statistical models. It also allows for greater flexibility when it comes to when the statistical model is supposed to run. For example, imagine that instead of every year, we want to fit it only at every 5 years, using the previous 5 years of data. By having the statistical analysis contained in its own module, we don't need to fiddle with the other module scripts in order to make these changes.
Finally, I'd like to draw your attention to a few differences in this module's script:
* The frequency of the statistical analysis (and correspondent plots) will be determined by the parameter `statsTimestep`. This parameter also determines the number of data years to be used to fit the linear model. If `statsTimestep` = 5, then the statistical analysis will use the precedent 5 years of data AND the year in which the event is running (a total of 6 years of data);
* The inputs required by the model are specified in `inputObjects` part of `defineModule` - notice how I've respected the names, classes and description of the objects that come from the `speciesAbundance` and the `temperature` modules;
* This time, we have two "extra functions" at the end of the script: the function fitting the linear model and a plotting function.

```{r stats_module, eval = FALSE}
defineModule(sim, list(
  name = "speciesTempLM",
  description = "Statistical analysis of species ~ temperature relationships using LM",
  keywords = c("linear model"),
  authors = person("Mr.", "Me", email = "mr.me@example.com", role = c("aut", "cre")),
  childModules = character(0),
  version = list(SpaDES.core = "0.1.0", speciesTempLM = "0.0.1", speciesAbundance = "0.0.1", temperature = "0.0.1", SpaDES.addins = "0.1.0", SpaDES.tools = "0.1.0"),
  spatialExtent = raster::extent(rep(NA_real_, 4)),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = list("README.txt", "speciesTempLM.Rmd"),
  reqdPkgs = list("raster"),
  parameters = rbind(
    #defineParameter("paramName", "paramClass", value, min, max, "parameter description"),
    defineParameter("statsTimestep", "numeric", 1, NA, NA, "This describes the how often the statitiscal analysis will be done")
  ),
  inputObjects = bind_rows(
    #expectsInput("objectName", "objectClass", "input object description", sourceURL, ...),
    expectsInput( "abundRasters", "list", "List of raster layers of species abundance at any given year"),
    expectsInput( "tempRasters", "list", "List of raster layers of temperature at any given year")
  ),
  outputObjects = bind_rows(
    #createsOutput("objectName", "objectClass", "output object description", ...),
    createsOutput("outputdata", "list", "List of dataframes containing species abundances and temperature values per pixel"),
    createsOutput( "outputLM", "list", "List of output yearly LMs (abundance ~ temperature)"),
    createsOutput( "yrs", "numeric", "Vector of years used for statistical analysis")
  )
))

## event types
#   - type `init` is required for initialiazation

doEvent.speciesTempLM = function(sim, eventTime, eventType, debug = FALSE) {
  switch(
    eventType,
    init = {
      ## do stuff for this event
      sim <- statsInit(sim)

      ## schedule future event(s)
      sim <- scheduleEvent(sim, P(sim)$statsTimestep, "speciesTempLM", "stats")
      sim <- scheduleEvent(sim, P(sim)$statsTimestep, "speciesTempLM", "plot")
    },
    plot = {
      ## do stuff for this event
      sim <- sim$statsPlot(sim)
      
      ## schedule future event(s)
      sim <- scheduleEvent(sim, time(sim) + P(sim)$statsTimestep, "speciesTempLM", "plot")
    },
    stats = {
      ## do stuff for this event
      sim <- statsAnalysis(sim)
      
      ## schedule future event(s)
      sim <- scheduleEvent(sim, time(sim) + P(sim)$statsTimestep, "speciesTempLM", "stats")
    },
    warning(paste("Undefined event type: '", current(sim)[1, "eventType", with = FALSE],
                  "' in module '", current(sim)[1, "moduleName", with = FALSE], "'", sep = ""))
  )
  return(invisible(sim))
}

## template initialization
statsInit <- function(sim) {
  ## create outputs storage lists
  sim$outputdata <- list()
  sim$outputLM <- list()
  
  return(invisible(sim))
}

## Plotting event
statsPlot <- function(sim) {

  plotLMResults(Data = sim$outputdata[[time(sim)]], model = sim$outputLM[[time(sim)]])
  
  return(invisible(sim))
}

## Statistical analysis event
statsAnalysis <- function(sim) {
  
  yrs <- seq(time(sim) - P(sim)$statsTimestep, time(sim), 1)

  sim$outputdata[[time(sim)]] <- do.call(rbind.data.frame, 
                                         lapply(yrs, FUN = function(y){
                                           temp <- data.frame(abund = sim$abundRasters[[y]][], temp = sim$tempRasters[[y]][], year = y)          
                                         }))
  
  sim$outputLM[[time(sim)]] <- stats_analysis(Data = sim$outputdata[[time(sim)]])
  
  return(invisible(sim))
}


## Other functions
stats_analysis <- function(Data){
  return(lm1 <- lm(abund ~ temp, data = Data))
}

plotLMResults <- function(Data, model){
  plot(Data$abund ~ Data$temp, xlab = "Temp.", ylab = "Species abundance")
  abline(a = model$coefficients["(Intercept)"], b = model$coefficients["temp"], lwd = 2, col = "blue")
}

```


### Let's play!
Ok, now that we have our modules ready we can set up the simulation. Let's go back to our *global.R* script.

```{r globalscript2}
## list the modules to use
modules <- list("speciesAbundance", "temperature", "speciesTempLM")

## Set simulation and module parameters
times <- list(start = 1.0, end = 50.0, timeunit = "year")
parameters <- list(
  .globals = list(simulationTimeStep = 1, .plotInitialTime = 1, .plotInterval = 1),
  speciesTempLM = list(statsTimestep = 5)
)

## make a list of directory paths
paths <- getPaths()

## Simulation setup
mySim <- simInit(times = times, params = parameters, 
                modules = modules, paths =  paths)
```

Before starting the simulations we should check if the modules were linked correctly. `moduleDiagram` is a useful function that shows module interdependencies as a network. The direction of the arrows indicates an output to input flow. You can seen that the outputs of the `speciesAbundance` and `tempreature` modules are inputs to the `speciesTempLM` module.
```{r modulediagram}
## check how your modules are linked
moduleDiagram(mySim)
```

`objectDiagram` provides yet another way of checking if the modules are linked correctly, by explicitly showing the objects that pass between modules.
```{r eventdiagram}
objectDiagram(mySim)
```


Ok, everything seems to be correct so far. Let's try to run the simulations. I have used `debug = TRUE` so that `spades` prints the events as they are being executed. In case something fails, we'll know where it stopped.
```{r spadesrun}
## run simulation
spades(mySim, debug = TRUE)
```


### Additional notes
* SpaDES is an extremely powerful package, whose potential goes well beyond what has been discussed in this dummy example. If you don't feel so dummy anymore and want to explore it further, have a look at the [LCC2005]() and the [wolfALps]() module tutorials. Also, do go to the [`SpaDES` webpage](http://predictiveecology.org/) to find further information about the package, as well as upcoming workshops and publications.
